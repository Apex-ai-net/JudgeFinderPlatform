[
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\api\\courtlistener\\client.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (612). Maximum allowed is 60.",
        "line": 22,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 650,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (95). Maximum allowed is 60.",
        "line": 96,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 194,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (132). Maximum allowed is 60.",
        "line": 196,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 329,
        "endColumn": 4
      },
      {
        "ruleId": "id-length",
        "severity": 1,
        "message": "Identifier name '_' is too short (< 2).",
        "line": 298,
        "column": 29,
        "nodeType": "Identifier",
        "messageId": "tooShort",
        "endLine": 298,
        "endColumn": 30
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (80). Maximum allowed is 60.",
        "line": 483,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 562,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 585,
        "column": 16,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 585,
        "endColumn": 19,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [17707, 17710], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [17707, 17710], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 6,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * CourtListener API Client Test Suite\r\n *\r\n * Tests the core CourtListener client implementation including:\r\n * - Authentication\r\n * - Rate limiting\r\n * - Error handling\r\n * - Retry logic\r\n * - Circuit breaker\r\n * - Request/response parsing\r\n */\r\n\r\nimport { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'\r\nimport { CourtListenerClient } from '@/lib/courtlistener/client'\r\n\r\n// Mock environment variables\r\nprocess.env.COURTLISTENER_API_KEY = 'test-api-key'\r\nprocess.env.COURTLISTENER_REQUEST_DELAY_MS = '100' // Faster for tests\r\nprocess.env.COURTLISTENER_MAX_RETRIES = '3'\r\nprocess.env.COURTLISTENER_REQUEST_TIMEOUT_MS = '5000'\r\n\r\ndescribe('CourtListenerClient', () => {\r\n  let client: CourtListenerClient\r\n  let fetchMock: ReturnType<typeof vi.fn>\r\n\r\n  beforeEach(() => {\r\n    // Mock fetch\r\n    fetchMock = vi.fn()\r\n    global.fetch = fetchMock\r\n\r\n    client = new CourtListenerClient()\r\n  })\r\n\r\n  afterEach(() => {\r\n    vi.restoreAllMocks()\r\n  })\r\n\r\n  describe('Authentication', () => {\r\n    it('should include Authorization header with Token prefix', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [] }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      await client.listJudges({ pageSize: 1 })\r\n\r\n      expect(fetchMock).toHaveBeenCalledTimes(1)\r\n      const callArgs = fetchMock.mock.calls[0]\r\n      const headers = callArgs[1].headers\r\n\r\n      expect(headers['Authorization']).toBe('Token test-api-key')\r\n    })\r\n\r\n    it('should throw error when API key is missing', () => {\r\n      delete process.env.COURTLISTENER_API_KEY\r\n      delete process.env.COURTLISTENER_API_TOKEN\r\n\r\n      expect(() => new CourtListenerClient()).toThrow(\r\n        'COURTLISTENER_API_KEY or COURTLISTENER_API_TOKEN environment variable is required'\r\n      )\r\n\r\n      // Restore for other tests\r\n      process.env.COURTLISTENER_API_KEY = 'test-api-key'\r\n    })\r\n\r\n    it('should accept COURTLISTENER_API_TOKEN as alternative', () => {\r\n      process.env.COURTLISTENER_API_TOKEN = 'alternative-token'\r\n      delete process.env.COURTLISTENER_API_KEY\r\n\r\n      const altClient = new CourtListenerClient()\r\n      expect(altClient).toBeInstanceOf(CourtListenerClient)\r\n\r\n      // Restore\r\n      process.env.COURTLISTENER_API_KEY = 'test-api-key'\r\n      delete process.env.COURTLISTENER_API_TOKEN\r\n    })\r\n\r\n    it('should include proper User-Agent header', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [] }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      await client.listJudges({ pageSize: 1 })\r\n\r\n      const headers = fetchMock.mock.calls[0][1].headers\r\n      expect(headers['User-Agent']).toContain('JudgeFinder')\r\n      expect(headers['User-Agent']).toContain('judgefinder.io')\r\n    })\r\n  })\r\n\r\n  describe('Rate Limiting', () => {\r\n    it('should enforce request delay between calls', async () => {\r\n      const startTime = Date.now()\r\n\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      await client.listJudges({ pageSize: 1 })\r\n      await client.listJudges({ pageSize: 1 })\r\n\r\n      const elapsed = Date.now() - startTime\r\n      // Should take at least 100ms (our test delay) between requests\r\n      expect(elapsed).toBeGreaterThanOrEqual(100)\r\n    })\r\n\r\n    it('should respect Retry-After header (seconds format)', async () => {\r\n      const retryAfterSeconds = 2\r\n\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 429,\r\n          text: async () => 'Rate limit exceeded',\r\n          headers: new Headers({ 'Retry-After': retryAfterSeconds.toString() })\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      const startTime = Date.now()\r\n      await client.listJudges({ pageSize: 1 })\r\n      const elapsed = Date.now() - startTime\r\n\r\n      // Should wait at least retryAfterSeconds * 1000ms\r\n      expect(elapsed).toBeGreaterThanOrEqual(retryAfterSeconds * 1000)\r\n    })\r\n\r\n    it('should respect Retry-After header (HTTP-date format)', async () => {\r\n      const retryDate = new Date(Date.now() + 1000) // 1 second from now\r\n\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 429,\r\n          text: async () => 'Rate limit exceeded',\r\n          headers: new Headers({ 'Retry-After': retryDate.toUTCString() })\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      const startTime = Date.now()\r\n      await client.listJudges({ pageSize: 1 })\r\n      const elapsed = Date.now() - startTime\r\n\r\n      expect(elapsed).toBeGreaterThanOrEqual(900) // Allow 100ms margin\r\n    })\r\n\r\n    it('should use longer backoff for 429 errors', async () => {\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 429,\r\n          text: async () => 'Rate limit exceeded',\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      const startTime = Date.now()\r\n      await client.listJudges({ pageSize: 1 })\r\n      const elapsed = Date.now() - startTime\r\n\r\n      // 429 should use 1.5x multiplier on backoff\r\n      // First retry: ~1000ms base * 1.5 = ~1500ms minimum\r\n      expect(elapsed).toBeGreaterThanOrEqual(1000)\r\n    })\r\n  })\r\n\r\n  describe('Error Handling', () => {\r\n    it('should retry on 500 server errors', async () => {\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Internal Server Error',\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      const result = await client.listJudges({ pageSize: 1 })\r\n\r\n      expect(fetchMock).toHaveBeenCalledTimes(2) // Original + 1 retry\r\n      expect(result.count).toBe(0)\r\n    })\r\n\r\n    it('should retry on network errors', async () => {\r\n      fetchMock\r\n        .mockRejectedValueOnce(new Error('Network error'))\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      const result = await client.listJudges({ pageSize: 1 })\r\n\r\n      expect(fetchMock).toHaveBeenCalledTimes(2)\r\n      expect(result.count).toBe(0)\r\n    })\r\n\r\n    it('should NOT retry on 404 errors (by default)', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: false,\r\n        status: 404,\r\n        text: async () => 'Not Found',\r\n        headers: new Headers()\r\n      })\r\n\r\n      await expect(client.listJudges({ pageSize: 1 })).rejects.toThrow(\r\n        'CourtListener API error 404'\r\n      )\r\n\r\n      expect(fetchMock).toHaveBeenCalledTimes(1) // No retry\r\n    })\r\n\r\n    it('should return null on 404 when allow404 is true', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: false,\r\n        status: 404,\r\n        text: async () => 'Not Found',\r\n        headers: new Headers()\r\n      })\r\n\r\n      const result = await client.getJudgeById('999999')\r\n\r\n      expect(result).toBeNull()\r\n      expect(fetchMock).toHaveBeenCalledTimes(1)\r\n    })\r\n\r\n    it('should throw error after max retries exhausted', async () => {\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Error 1',\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Error 2',\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Error 3',\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Error 4',\r\n          headers: new Headers()\r\n        })\r\n\r\n      await expect(client.listJudges({ pageSize: 1 })).rejects.toThrow()\r\n\r\n      // Should have tried: original + 3 retries = 4 attempts\r\n      expect(fetchMock).toHaveBeenCalledTimes(4)\r\n    })\r\n\r\n    it('should handle timeout errors', async () => {\r\n      fetchMock.mockImplementationOnce(() => {\r\n        return new Promise((_, reject) => {\r\n          setTimeout(() => reject(new Error('AbortError')), 100)\r\n        })\r\n      })\r\n\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [], count: 0, next: null }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      // Should retry after timeout\r\n      const result = await client.listJudges({ pageSize: 1 })\r\n      expect(result.count).toBe(0)\r\n    })\r\n\r\n    it('should NOT retry on 400 Bad Request', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: false,\r\n        status: 400,\r\n        text: async () => 'Bad Request',\r\n        headers: new Headers()\r\n      })\r\n\r\n      await expect(client.listJudges({ pageSize: 1 })).rejects.toThrow(\r\n        'CourtListener API error 400'\r\n      )\r\n\r\n      expect(fetchMock).toHaveBeenCalledTimes(1)\r\n    })\r\n  })\r\n\r\n  describe('Circuit Breaker', () => {\r\n    it('should open circuit after threshold failures', async () => {\r\n      // Mock 5 consecutive failures (circuit threshold)\r\n      for (let i = 0; i < 5; i++) {\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Server Error',\r\n          headers: new Headers()\r\n        })\r\n      }\r\n\r\n      // Try to make requests\r\n      for (let i = 0; i < 5; i++) {\r\n        try {\r\n          await client.listJudges({ pageSize: 1 })\r\n        } catch (error) {\r\n          // Expected to fail\r\n        }\r\n      }\r\n\r\n      // Next request should be circuit breaker error\r\n      await expect(client.listJudges({ pageSize: 1 })).rejects.toThrow(\r\n        'circuit open'\r\n      )\r\n    })\r\n\r\n    it('should reset circuit on successful request', async () => {\r\n      // Cause some failures\r\n      fetchMock\r\n        .mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 500,\r\n          text: async () => 'Error',\r\n          headers: new Headers()\r\n        })\r\n        .mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n      await client.listJudges({ pageSize: 1 })\r\n\r\n      // Circuit should be closed now\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [], count: 0, next: null }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      const result = await client.listJudges({ pageSize: 1 })\r\n      expect(result.count).toBe(0)\r\n    })\r\n  })\r\n\r\n  describe('Request Formatting', () => {\r\n    it('should add format=json parameter', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [], count: 0, next: null }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      await client.listJudges({ pageSize: 1 })\r\n\r\n      const requestUrl = fetchMock.mock.calls[0][0]\r\n      expect(requestUrl).toContain('format=json')\r\n    })\r\n\r\n    it('should properly encode query parameters', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [], count: 0, next: null }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      await client.listJudges({\r\n        pageSize: 50,\r\n        ordering: '-date_modified',\r\n        filters: { name: 'John Doe' }\r\n      })\r\n\r\n      const requestUrl = fetchMock.mock.calls[0][0]\r\n      expect(requestUrl).toContain('page_size=50')\r\n      expect(requestUrl).toContain('ordering=-date_modified')\r\n      expect(requestUrl).toContain('name=John+Doe')\r\n    })\r\n\r\n    it('should handle absolute URLs (pagination)', async () => {\r\n      const nextUrl = 'https://www.courtlistener.com/api/rest/v4/people/?page=2'\r\n\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [], count: 0, next: null }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      await client.listJudges({ cursorUrl: nextUrl })\r\n\r\n      const requestUrl = fetchMock.mock.calls[0][0]\r\n      expect(requestUrl).toBe(nextUrl + '&format=json')\r\n    })\r\n  })\r\n\r\n  describe('Response Parsing', () => {\r\n    it('should parse successful JSON response', async () => {\r\n      const mockData = {\r\n        count: 100,\r\n        next: 'https://example.com/next',\r\n        previous: null,\r\n        results: [\r\n          { id: 1, name: 'Judge 1' },\r\n          { id: 2, name: 'Judge 2' }\r\n        ]\r\n      }\r\n\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => mockData,\r\n        headers: new Headers()\r\n      })\r\n\r\n      const result = await client.listJudges({ pageSize: 2 })\r\n\r\n      expect(result.count).toBe(100)\r\n      expect(result.results).toHaveLength(2)\r\n      expect(result.next).toBeTruthy()\r\n    })\r\n\r\n    it('should handle empty results', async () => {\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: true,\r\n        status: 200,\r\n        json: async () => ({ results: [], count: 0, next: null }),\r\n        headers: new Headers()\r\n      })\r\n\r\n      const result = await client.listJudges({ pageSize: 10 })\r\n\r\n      expect(result.count).toBe(0)\r\n      expect(result.results).toHaveLength(0)\r\n      expect(result.next).toBeNull()\r\n    })\r\n  })\r\n\r\n  describe('Specific Endpoint Methods', () => {\r\n    describe('getOpinionsByJudge', () => {\r\n      it('should fetch opinions with proper filters', async () => {\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n        await client.getOpinionsByJudge('12345', {\r\n          startDate: '2023-01-01',\r\n          endDate: '2023-12-31',\r\n          limit: 50\r\n        })\r\n\r\n        const requestUrl = fetchMock.mock.calls[0][0]\r\n        expect(requestUrl).toContain('author=12345')\r\n        expect(requestUrl).toContain('cluster__date_filed__gte=2023-01-01')\r\n        expect(requestUrl).toContain('cluster__date_filed__lte=2023-12-31')\r\n        expect(requestUrl).toContain('page_size=50')\r\n        expect(requestUrl).toContain('ordering=-date_created')\r\n      })\r\n    })\r\n\r\n    describe('getDocketsByJudge', () => {\r\n      it('should fetch dockets with assigned_to_id', async () => {\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n        await client.getDocketsByJudge('12345', {\r\n          startDate: '2023-01-01',\r\n          limit: 25\r\n        })\r\n\r\n        const requestUrl = fetchMock.mock.calls[0][0]\r\n        expect(requestUrl).toContain('assigned_to_id=12345')\r\n        expect(requestUrl).toContain('date_filed__gte=2023-01-01')\r\n        expect(requestUrl).toContain('page_size=25')\r\n      })\r\n    })\r\n\r\n    describe('getJudgeById', () => {\r\n      it('should fetch specific judge by ID', async () => {\r\n        const mockJudge = {\r\n          id: '12345',\r\n          name: 'John Doe',\r\n          positions: []\r\n        }\r\n\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => mockJudge,\r\n          headers: new Headers()\r\n        })\r\n\r\n        const result = await client.getJudgeById('12345')\r\n\r\n        expect(result).toEqual(mockJudge)\r\n        expect(fetchMock.mock.calls[0][0]).toContain('/people/12345/')\r\n      })\r\n\r\n      it('should return null for non-existent judge', async () => {\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: false,\r\n          status: 404,\r\n          text: async () => 'Not Found',\r\n          headers: new Headers()\r\n        })\r\n\r\n        const result = await client.getJudgeById('999999')\r\n        expect(result).toBeNull()\r\n      })\r\n    })\r\n  })\r\n\r\n  describe('Metrics Reporting', () => {\r\n    it('should report metrics when reporter is configured', async () => {\r\n      const metricsReporter = vi.fn()\r\n      client.setMetricsReporter(metricsReporter)\r\n\r\n      fetchMock.mockResolvedValueOnce({\r\n        ok: false,\r\n        status: 429,\r\n        text: async () => 'Rate Limited',\r\n        headers: new Headers()\r\n      })\r\n\r\n      try {\r\n        await client.listJudges({ pageSize: 1 })\r\n      } catch (error) {\r\n        // Expected to fail\r\n      }\r\n\r\n      // Should have reported retry metric\r\n      expect(metricsReporter).toHaveBeenCalled()\r\n      expect(metricsReporter.mock.calls.some(\r\n        (call: any[]) => call[0] === 'courtlistener_retry'\r\n      )).toBe(true)\r\n    })\r\n  })\r\n\r\n  describe('Helper Functions', () => {\r\n    describe('transformOpinionToCase', () => {\r\n      it('should transform opinion data to case format', () => {\r\n        const opinionData = {\r\n          opinion_id: 12345,\r\n          case_name: 'Test v. Case',\r\n          date_filed: '2023-06-15',\r\n          precedential_status: 'Published'\r\n        }\r\n\r\n        const result = client.transformOpinionToCase(opinionData, 'judge-123')\r\n\r\n        expect(result.judge_id).toBe('judge-123')\r\n        expect(result.case_name).toBe('Test v. Case')\r\n        expect(result.case_number).toBe('CL-O12345')\r\n        expect(result.decision_date).toBe('2023-06-15')\r\n        expect(result.outcome).toBe('Published')\r\n        expect(result.case_type).toBe('Opinion')\r\n      })\r\n\r\n      it('should truncate long case names', () => {\r\n        const longName = 'A'.repeat(600)\r\n        const opinionData = {\r\n          opinion_id: 12345,\r\n          case_name: longName,\r\n          date_filed: '2023-06-15'\r\n        }\r\n\r\n        const result = client.transformOpinionToCase(opinionData, 'judge-123')\r\n\r\n        expect(result.case_name.length).toBe(500)\r\n      })\r\n    })\r\n\r\n    describe('validateJudge', () => {\r\n      it('should return true if judge has opinions', async () => {\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [{ id: 1 }], count: 1, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n        const result = await client.validateJudge('12345')\r\n        expect(result).toBe(true)\r\n      })\r\n\r\n      it('should return false if judge has no opinions', async () => {\r\n        fetchMock.mockResolvedValueOnce({\r\n          ok: true,\r\n          status: 200,\r\n          json: async () => ({ results: [], count: 0, next: null }),\r\n          headers: new Headers()\r\n        })\r\n\r\n        const result = await client.validateJudge('12345')\r\n        expect(result).toBe(false)\r\n      })\r\n    })\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\e2e\\auth\\sign-up-flow.spec.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (193). Maximum allowed is 60.",
        "line": 8,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 220,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * E2E tests for user sign-up flow\r\n * Tests complete registration journey with Clerk authentication\r\n */\r\n\r\nimport { test, expect } from '@playwright/test'\r\n\r\ntest.describe('User Sign-Up Flow', () => {\r\n  test('should display sign-up option on homepage', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    // Look for sign-up or login buttons\r\n    const authButtons = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started|login|sign in/i })\r\n\r\n    const hasAuthOption = (await authButtons.count()) > 0\r\n\r\n    expect(hasAuthOption).toBeTruthy()\r\n  })\r\n\r\n  test('should navigate to sign-up page', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    // Find and click sign-up button\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n\r\n      // Should navigate to sign-up page or show modal\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Check if Clerk sign-up form is visible\r\n      const hasSignUpForm =\r\n        (await page.getByText(/email|create account|password/i).count()) > 0 ||\r\n        (await page.frameLocator('iframe').locator('input[type=\"email\"]').count()) > 0\r\n\r\n      expect(hasSignUpForm).toBeTruthy()\r\n    }\r\n  })\r\n\r\n  test('should validate email format', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    // Navigate to sign-up\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Try to enter invalid email\r\n      const emailInput = page.getByRole('textbox', { name: /email/i }).first()\r\n\r\n      if ((await emailInput.count()) > 0) {\r\n        await emailInput.fill('invalid-email')\r\n        await emailInput.press('Tab')\r\n\r\n        await page.waitForTimeout(500)\r\n\r\n        // Should show validation error\r\n        const hasError =\r\n          (await page.getByText(/invalid|valid email|email format/i).count()) > 0\r\n\r\n        // Validation might be on submit, so we just verify no crash\r\n        expect(page.url()).toBeTruthy()\r\n      }\r\n    }\r\n  })\r\n\r\n  test('should require password', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Find email and password fields\r\n      const emailInput = page.getByRole('textbox', { name: /email/i }).first()\r\n      const continueButton = page\r\n        .getByRole('button')\r\n        .filter({ hasText: /continue|next|sign up/i })\r\n        .first()\r\n\r\n      if ((await emailInput.count()) > 0 && (await continueButton.count()) > 0) {\r\n        await emailInput.fill('test@example.com')\r\n\r\n        // Try to proceed without password\r\n        await continueButton.click()\r\n\r\n        await page.waitForTimeout(500)\r\n\r\n        // Should require password or show error\r\n        expect(page.url()).toBeTruthy()\r\n      }\r\n    }\r\n  })\r\n\r\n  test('should handle existing email gracefully', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      const emailInput = page.getByRole('textbox', { name: /email/i }).first()\r\n\r\n      if ((await emailInput.count()) > 0) {\r\n        // Try with a commonly used test email\r\n        await emailInput.fill('admin@judgefinder.io')\r\n\r\n        const continueButton = page\r\n          .getByRole('button')\r\n          .filter({ hasText: /continue|next|sign up/i })\r\n          .first()\r\n\r\n        if ((await continueButton.count()) > 0) {\r\n          await continueButton.click()\r\n          await page.waitForTimeout(1000)\r\n\r\n          // Should show error or redirect to login\r\n          expect(page.url()).toBeTruthy()\r\n        }\r\n      }\r\n    }\r\n  })\r\n\r\n  test('should allow navigation to login from sign-up', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Look for \"Already have an account?\" or \"Sign in\" link\r\n      const loginLink = page.getByRole('link').filter({ hasText: /sign in|log in|login/i })\r\n\r\n      if ((await loginLink.count()) > 0) {\r\n        await loginLink.first().click()\r\n        await page.waitForTimeout(1000)\r\n\r\n        // Should show login form\r\n        const hasLoginForm = (await page.getByText(/email|password|sign in/i).count()) > 0\r\n\r\n        expect(hasLoginForm).toBeTruthy()\r\n      }\r\n    }\r\n  })\r\n\r\n  test('should display terms and privacy links', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Check for legal links\r\n      const termsLink = page.getByRole('link').filter({ hasText: /terms|privacy/i })\r\n\r\n      // Legal links are optional but good to have\r\n      if ((await termsLink.count()) > 0) {\r\n        expect(await termsLink.count()).toBeGreaterThan(0)\r\n      }\r\n    }\r\n  })\r\n\r\n  test('should handle social sign-up options', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Look for social sign-up buttons\r\n      const socialButtons = page\r\n        .getByRole('button')\r\n        .filter({ hasText: /google|github|continue with/i })\r\n\r\n      if ((await socialButtons.count()) > 0) {\r\n        // Social auth is available\r\n        expect(await socialButtons.count()).toBeGreaterThan(0)\r\n      } else {\r\n        // Email-only auth is also acceptable\r\n        expect(page.url()).toBeTruthy()\r\n      }\r\n    }\r\n  })\r\n})\r\n\r\ntest.describe('User Sign-Up - Mobile', () => {\r\n  test.use({ viewport: { width: 375, height: 667 } })\r\n\r\n  test('should work on mobile viewport', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const signUpButton = page\r\n      .getByRole('link')\r\n      .filter({ hasText: /sign up|register|get started/i })\r\n      .first()\r\n\r\n    if ((await signUpButton.count()) > 0) {\r\n      await signUpButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      // Should display sign-up form in mobile layout\r\n      const hasForm =\r\n        (await page.getByText(/email|sign up|create/i).count()) > 0 ||\r\n        page.url().includes('sign-up') ||\r\n        page.url().includes('register')\r\n\r\n      expect(hasForm || page.url()).toBeTruthy()\r\n    }\r\n  })\r\n})\r\n\r\ntest.describe('Login Flow', () => {\r\n  test('should display login option', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const loginButton = page.getByRole('link').filter({ hasText: /login|sign in/i }).first()\r\n\r\n    const hasLoginOption = (await loginButton.count()) > 0\r\n\r\n    expect(hasLoginOption).toBeTruthy()\r\n  })\r\n\r\n  test('should navigate to login page', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const loginButton = page.getByRole('link').filter({ hasText: /login|sign in/i }).first()\r\n\r\n    if ((await loginButton.count()) > 0) {\r\n      await loginButton.click()\r\n      await page.waitForTimeout(1000)\r\n\r\n      const hasLoginForm =\r\n        (await page.getByText(/email|password|sign in/i).count()) > 0 ||\r\n        page.url().includes('sign-in') ||\r\n        page.url().includes('login')\r\n\r\n      expect(hasLoginForm || page.url()).toBeTruthy()\r\n    }\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\e2e\\search\\judge-search.spec.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (138). Maximum allowed is 60.",
        "line": 8,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 168,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * E2E tests for judge search flow\r\n * Tests the complete user journey: Search → Profile → Analytics\r\n */\r\n\r\nimport { test, expect } from '@playwright/test'\r\n\r\ntest.describe('Judge Search Flow', () => {\r\n  test.beforeEach(async ({ page }) => {\r\n    await page.goto('/')\r\n  })\r\n\r\n  test('should display search interface on home page', async ({ page }) => {\r\n    // Check for search input\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await expect(searchInput).toBeVisible()\r\n  })\r\n\r\n  test('should search for judges and display results', async ({ page }) => {\r\n    // Enter search query\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await searchInput.fill('Smith')\r\n    await searchInput.press('Enter')\r\n\r\n    // Wait for results or navigate to results page\r\n    await page.waitForURL(/search|results/i, { timeout: 10000 }).catch(() => {\r\n      // If URL doesn't change, results might be on same page\r\n    })\r\n\r\n    // Check if any results are displayed\r\n    // This is flexible to accommodate different UI implementations\r\n    const hasResults =\r\n      (await page.getByText(/judge/i).count()) > 0 || (await page.getByText(/results/i).count()) > 0\r\n\r\n    expect(hasResults).toBeTruthy()\r\n  })\r\n\r\n  test('should navigate to judge profile from search results', async ({ page }) => {\r\n    // Perform search\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await searchInput.fill('judge')\r\n    await searchInput.press('Enter')\r\n\r\n    // Wait for results\r\n    await page.waitForTimeout(2000)\r\n\r\n    // Try to find and click first judge link\r\n    const judgeLinks = page.getByRole('link').filter({ hasText: /judge|court/i })\r\n    const firstJudge = judgeLinks.first()\r\n\r\n    if ((await firstJudge.count()) > 0) {\r\n      await firstJudge.click()\r\n\r\n      // Should navigate to judge profile\r\n      await page.waitForURL(/judges\\//, { timeout: 10000 })\r\n      expect(page.url()).toContain('judges/')\r\n    }\r\n  })\r\n\r\n  test('should display judge profile information', async ({ page }) => {\r\n    // Navigate directly to a judge profile page\r\n    // Using a common pattern - actual slug may vary\r\n    await page.goto('/judges/john-smith').catch(async () => {\r\n      // If specific judge doesn't exist, search for one\r\n      await page.goto('/')\r\n      const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n      await searchInput.fill('judge')\r\n      await searchInput.press('Enter')\r\n      await page.waitForTimeout(1000)\r\n\r\n      const judgeLink = page.getByRole('link').filter({ hasText: /judge/i }).first()\r\n      if ((await judgeLink.count()) > 0) {\r\n        await judgeLink.click()\r\n      }\r\n    })\r\n\r\n    // Check for profile elements\r\n    const hasProfileContent =\r\n      (await page.getByText(/court/i).count()) > 0 || (await page.getByText(/jurisdiction/i).count()) > 0\r\n\r\n    expect(hasProfileContent).toBeTruthy()\r\n  })\r\n\r\n  test('should handle empty search gracefully', async ({ page }) => {\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await searchInput.fill('')\r\n    await searchInput.press('Enter')\r\n\r\n    // Should not crash and should show some feedback\r\n    await page.waitForTimeout(1000)\r\n    expect(page.url()).toBeTruthy()\r\n  })\r\n\r\n  test('should sanitize malicious input', async ({ page }) => {\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await searchInput.fill('<script>alert(\"xss\")</script>')\r\n    await searchInput.press('Enter')\r\n\r\n    await page.waitForTimeout(1000)\r\n\r\n    // Should not execute script\r\n    // If alert appears, test would fail\r\n    const hasNoAlert = !(await page.locator('.alert, [role=\"alert\"]').count())\r\n    expect(hasNoAlert).toBeTruthy()\r\n  })\r\n\r\n  test('should filter search results by type', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await searchInput.fill('california')\r\n    await searchInput.press('Enter')\r\n\r\n    await page.waitForTimeout(1500)\r\n\r\n    // Look for filter controls (if they exist)\r\n    const filterButtons = page.getByRole('button').filter({ hasText: /judge|court|filter/i })\r\n    if ((await filterButtons.count()) > 0) {\r\n      await filterButtons.first().click()\r\n      await page.waitForTimeout(500)\r\n\r\n      // Results should be filtered\r\n      expect(page.url()).toBeTruthy()\r\n    }\r\n  })\r\n\r\n  test('should show search suggestions while typing', async ({ page }) => {\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n\r\n    // Type slowly to trigger suggestions\r\n    await searchInput.type('jud', { delay: 100 })\r\n    await page.waitForTimeout(500)\r\n\r\n    // Check if suggestions dropdown appears\r\n    const hasSuggestions =\r\n      (await page.getByRole('listbox').count()) > 0 ||\r\n      (await page.locator('[role=\"option\"]').count()) > 0 ||\r\n      (await page.getByText(/suggestion|result/i).count()) > 0\r\n\r\n    // Suggestions are optional, so we just verify no crash occurred\r\n    expect(page.url()).toBeTruthy()\r\n  })\r\n\r\n  test('should navigate between search results pages', async ({ page }) => {\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await searchInput.fill('judge')\r\n    await searchInput.press('Enter')\r\n\r\n    await page.waitForTimeout(1500)\r\n\r\n    // Look for pagination controls\r\n    const nextButton = page\r\n      .getByRole('button')\r\n      .filter({ hasText: /next|>/i })\r\n      .first()\r\n    const paginationLinks = page.getByRole('link').filter({ hasText: /\\d+|next|previous/i })\r\n\r\n    if ((await nextButton.count()) > 0) {\r\n      await nextButton.click()\r\n      await page.waitForTimeout(500)\r\n      expect(page.url()).toBeTruthy()\r\n    } else if ((await paginationLinks.count()) > 0) {\r\n      await paginationLinks.first().click()\r\n      await page.waitForTimeout(500)\r\n      expect(page.url()).toBeTruthy()\r\n    }\r\n  })\r\n})\r\n\r\ntest.describe('Judge Search - Mobile', () => {\r\n  test.use({ viewport: { width: 375, height: 667 } })\r\n\r\n  test('should work on mobile viewport', async ({ page }) => {\r\n    await page.goto('/')\r\n\r\n    const searchInput = page.getByRole('searchbox').or(page.getByPlaceholder(/search/i))\r\n    await expect(searchInput).toBeVisible()\r\n\r\n    await searchInput.fill('judge')\r\n    await searchInput.press('Enter')\r\n\r\n    await page.waitForTimeout(1500)\r\n\r\n    // Should display results in mobile layout\r\n    expect(page.url()).toBeTruthy()\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\fixtures\\cases.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 100,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 100,
        "endColumn": 34
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 133,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 133,
        "endColumn": 31
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 143,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 143,
        "endColumn": 48
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 168,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 168,
        "endColumn": 36
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 190,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 190,
        "endColumn": 45
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 214,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 214,
        "endColumn": 41
      },
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 246,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 246,
        "endColumn": 37
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Test fixtures for case data\n */\n\nexport const mockCases = {\n  civilCase: {\n    id: 'case-001',\n    judge_id: 'judge-001',\n    case_number: 'CV-2023-12345',\n    case_name: 'Smith v. Jones',\n    case_type: 'Civil',\n    filing_date: '2023-01-15',\n    decision_date: '2023-06-20',\n    status: 'Closed',\n    outcome: 'Settled',\n    case_value: 150000,\n    court_id: 'court-la-001',\n    jurisdiction: 'CA',\n    created_at: '2023-01-15T00:00:00Z',\n    updated_at: '2023-06-20T00:00:00Z',\n  },\n\n  criminalCase: {\n    id: 'case-002',\n    judge_id: 'judge-001',\n    case_number: 'CR-2023-54321',\n    case_name: 'People v. Defendant',\n    case_type: 'Criminal',\n    filing_date: '2023-02-10',\n    decision_date: '2023-08-15',\n    status: 'Closed',\n    outcome: 'Judgment',\n    case_value: null,\n    court_id: 'court-la-001',\n    jurisdiction: 'CA',\n    created_at: '2023-02-10T00:00:00Z',\n    updated_at: '2023-08-15T00:00:00Z',\n  },\n\n  familyCase: {\n    id: 'case-003',\n    judge_id: 'judge-002',\n    case_number: 'FL-2023-99999',\n    case_name: 'In Re: Marriage of Smith',\n    case_type: 'Family',\n    filing_date: '2023-03-01',\n    decision_date: '2023-09-30',\n    status: 'Closed',\n    outcome: 'Settled',\n    case_value: 50000,\n    court_id: 'court-oc-001',\n    jurisdiction: 'CA',\n    created_at: '2023-03-01T00:00:00Z',\n    updated_at: '2023-09-30T00:00:00Z',\n  },\n\n  pendingCase: {\n    id: 'case-004',\n    judge_id: 'judge-001',\n    case_number: 'CV-2024-11111',\n    case_name: 'Acme Corp v. Widgets Inc',\n    case_type: 'Civil',\n    filing_date: '2024-01-05',\n    decision_date: null,\n    status: 'Pending',\n    outcome: null,\n    case_value: 500000,\n    court_id: 'court-la-001',\n    jurisdiction: 'CA',\n    created_at: '2024-01-05T00:00:00Z',\n    updated_at: '2024-01-05T00:00:00Z',\n  },\n\n  dismissedCase: {\n    id: 'case-005',\n    judge_id: 'judge-001',\n    case_number: 'CV-2023-22222',\n    case_name: 'Plaintiff v. Defendant Corp',\n    case_type: 'Civil',\n    filing_date: '2023-04-12',\n    decision_date: '2023-05-20',\n    status: 'Closed',\n    outcome: 'Dismissed',\n    case_value: 75000,\n    court_id: 'court-la-001',\n    jurisdiction: 'CA',\n    created_at: '2023-04-12T00:00:00Z',\n    updated_at: '2023-05-20T00:00:00Z',\n  },\n}\n\nexport const mockCasesList = [\n  mockCases.civilCase,\n  mockCases.criminalCase,\n  mockCases.familyCase,\n  mockCases.pendingCase,\n  mockCases.dismissedCase,\n]\n\nexport function generateMockCases(count: number, judgeId: string = 'judge-001') {\n  const cases = []\n  const types = ['Civil', 'Criminal', 'Family']\n  const outcomes = ['Settled', 'Judgment', 'Dismissed']\n\n  for (let i = 0; i < count; i++) {\n    const type = types[i % types.length]\n    const outcome = outcomes[i % outcomes.length]\n    const filingDate = new Date(2023, i % 12, (i % 28) + 1)\n    const decisionDate = new Date(filingDate)\n    decisionDate.setMonth(decisionDate.getMonth() + Math.floor(Math.random() * 6) + 1)\n\n    cases.push({\n      id: `case-${String(i + 1).padStart(3, '0')}`,\n      judge_id: judgeId,\n      case_number: `${type.substring(0, 2).toUpperCase()}-2023-${String(10000 + i).padStart(5, '0')}`,\n      case_name: `Case ${i + 1} v. Defendant`,\n      case_type: type,\n      filing_date: filingDate.toISOString().split('T')[0],\n      decision_date: decisionDate.toISOString().split('T')[0],\n      status: 'Closed',\n      outcome,\n      case_value: type === 'Civil' ? Math.floor(Math.random() * 1000000) : null,\n      court_id: 'court-la-001',\n      jurisdiction: 'CA',\n      created_at: filingDate.toISOString(),\n      updated_at: decisionDate.toISOString(),\n    })\n  }\n\n  return cases\n}\n\nexport function createMockCase(overrides: Partial<typeof mockCases.civilCase> = {}) {\n  return {\n    ...mockCases.civilCase,\n    ...overrides,\n  }\n}\n\n/**\n * Generate cases with specific settlement rate\n */\nexport function generateCasesWithSettlementRate(\n  total: number,\n  settlementRate: number,\n  judgeId: string = 'judge-001'\n) {\n  const settledCount = Math.floor(total * settlementRate)\n  const cases = []\n\n  for (let i = 0; i < total; i++) {\n    const isSettled = i < settledCount\n    cases.push(\n      createMockCase({\n        id: `case-settlement-${i}`,\n        judge_id: judgeId,\n        outcome: isSettled ? 'Settled' : 'Judgment',\n      })\n    )\n  }\n\n  return cases\n}\n\n/**\n * Generate cases with specific case type distribution\n */\nexport function generateCasesByType(counts: Record<string, number>, judgeId: string = 'judge-001') {\n  const cases = []\n  let caseId = 0\n\n  for (const [caseType, count] of Object.entries(counts)) {\n    for (let i = 0; i < count; i++) {\n      cases.push(\n        createMockCase({\n          id: `case-type-${caseId++}`,\n          judge_id: judgeId,\n          case_type: caseType,\n        })\n      )\n    }\n  }\n\n  return cases\n}\n\n/**\n * Generate cases with missing data for edge case testing\n */\nexport function generateCasesWithMissingData(count: number) {\n  const cases = []\n  for (let i = 0; i < count; i++) {\n    const missingField = i % 4\n    const baseCase = createMockCase({ id: `case-missing-${i}` })\n\n    if (missingField === 0) {\n      baseCase.outcome = null\n    } else if (missingField === 1) {\n      baseCase.decision_date = null\n    } else if (missingField === 2) {\n      baseCase.filing_date = null\n    } else {\n      baseCase.case_value = null\n    }\n\n    cases.push(baseCase)\n  }\n  return cases\n}\n\n/**\n * Generate cases within a specific date range\n */\nexport function generateCasesInDateRange(\n  count: number,\n  startDate: string,\n  endDate: string,\n  judgeId: string = 'judge-001'\n) {\n  const start = new Date(startDate)\n  const end = new Date(endDate)\n  const cases = []\n\n  for (let i = 0; i < count; i++) {\n    const randomTime = start.getTime() + Math.random() * (end.getTime() - start.getTime())\n    const randomDate = new Date(randomTime)\n\n    cases.push(\n      createMockCase({\n        id: `case-date-${i}`,\n        judge_id: judgeId,\n        filing_date: randomDate.toISOString().split('T')[0],\n        decision_date: new Date(randomDate.getTime() + 90 * 24 * 60 * 60 * 1000)\n          .toISOString()\n          .split('T')[0],\n      })\n    )\n  }\n\n  return cases\n}\n\n/**\n * Generate large dataset for comprehensive testing (500+ cases minimum)\n */\nexport function generateLargeDataset(judgeId: string = 'judge-001') {\n  return [\n    ...generateCasesByType({ Civil: 300, Criminal: 150, Family: 100 }, judgeId),\n    ...generateCasesWithSettlementRate(50, 0.6, judgeId),\n  ]\n}\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\fixtures\\judges.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 129,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 129,
        "endColumn": 32
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Test fixtures for judge data\n */\n\nexport const mockJudges = {\n  activeJudge: {\n    id: 'judge-001',\n    name: 'John Smith',\n    slug: 'john-smith',\n    court_name: 'Los Angeles Superior Court',\n    jurisdiction: 'CA',\n    total_cases: 1250,\n    profile_image_url: null,\n    bio: 'Experienced judge with focus on civil litigation',\n    education: ['Harvard Law School', 'Yale University'],\n    bar_admissions: ['California State Bar'],\n    prior_experience: ['Private practice', 'Deputy District Attorney'],\n    current_position: 'Superior Court Judge',\n    appointment_date: '2015-06-15',\n    retirement_date: null,\n    is_active: true,\n    court_id: 'court-la-001',\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-15T00:00:00Z',\n  },\n\n  retiredJudge: {\n    id: 'judge-002',\n    name: 'Jane Doe',\n    slug: 'jane-doe',\n    court_name: 'Orange County Superior Court',\n    jurisdiction: 'CA',\n    total_cases: 2500,\n    profile_image_url: null,\n    bio: 'Retired judge specializing in family law',\n    education: ['Stanford Law School'],\n    bar_admissions: ['California State Bar'],\n    prior_experience: ['Family law attorney'],\n    current_position: 'Retired',\n    appointment_date: '2005-03-20',\n    retirement_date: '2023-12-31',\n    is_active: false,\n    court_id: 'court-oc-001',\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-01T00:00:00Z',\n  },\n\n  federalJudge: {\n    id: 'judge-003',\n    name: 'Robert Johnson',\n    slug: 'robert-johnson',\n    court_name: 'U.S. District Court Central District of California',\n    jurisdiction: 'F',\n    total_cases: 850,\n    profile_image_url: null,\n    bio: 'Federal judge appointed in 2018',\n    education: ['UC Berkeley School of Law'],\n    bar_admissions: ['California State Bar', 'Federal Bar'],\n    prior_experience: ['U.S. Attorney', 'Law professor'],\n    current_position: 'Federal District Judge',\n    appointment_date: '2018-09-10',\n    retirement_date: null,\n    is_active: true,\n    court_id: 'court-federal-001',\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-10T00:00:00Z',\n  },\n\n  minimalDataJudge: {\n    id: 'judge-004',\n    name: 'Maria Garcia',\n    slug: 'maria-garcia',\n    court_name: 'San Diego Superior Court',\n    jurisdiction: 'CA',\n    total_cases: 50,\n    profile_image_url: null,\n    bio: null,\n    education: [],\n    bar_admissions: [],\n    prior_experience: [],\n    current_position: 'Superior Court Judge',\n    appointment_date: '2023-01-15',\n    retirement_date: null,\n    is_active: true,\n    court_id: 'court-sd-001',\n    created_at: '2024-01-01T00:00:00Z',\n    updated_at: '2024-01-01T00:00:00Z',\n  },\n}\n\nexport const mockJudgesList = [\n  mockJudges.activeJudge,\n  mockJudges.retiredJudge,\n  mockJudges.federalJudge,\n  mockJudges.minimalDataJudge,\n]\n\nexport const mockJudgeAnalytics = {\n  judge_id: 'judge-001',\n  total_cases: 1250,\n  avg_case_duration: 180,\n  settlement_rate: 0.65,\n  dismissal_rate: 0.15,\n  judgment_rate: 0.2,\n  case_types: [\n    { type: 'Civil', count: 750, settlement_rate: 0.7 },\n    { type: 'Criminal', count: 350, settlement_rate: 0.45 },\n    { type: 'Family', count: 150, settlement_rate: 0.8 },\n  ],\n  temporal_patterns: [\n    { year: 2023, month: 1, case_count: 45, settlement_rate: 0.67 },\n    { year: 2023, month: 2, case_count: 52, settlement_rate: 0.63 },\n    { year: 2023, month: 3, case_count: 48, settlement_rate: 0.69 },\n  ],\n  bias_indicators: {\n    consistency_score: 78.5,\n    speed_score: 72.3,\n    settlement_preference: 15.0,\n    risk_tolerance: 45.2,\n    predictability_score: 82.1,\n  },\n  confidence_civil: 0.92,\n  confidence_criminal: 0.88,\n  confidence_family: 0.75,\n  created_at: '2024-01-15T00:00:00Z',\n  updated_at: '2024-01-15T00:00:00Z',\n}\n\nexport function createMockJudge(overrides: Partial<typeof mockJudges.activeJudge> = {}) {\n  return {\n    ...mockJudges.activeJudge,\n    ...overrides,\n  }\n}\n\n/**\n * Additional judges for name matching tests\n */\nexport const mockJudgesForNameMatching = {\n  judgeWithSuffix: createMockJudge({\n    id: 'judge-005',\n    name: 'William James Thompson Jr.',\n    slug: 'william-james-thompson-jr',\n  }),\n\n  judgeWithInitial: createMockJudge({\n    id: 'judge-006',\n    name: 'Mary K. Johnson',\n    slug: 'mary-k-johnson',\n  }),\n\n  judgeWithHyphen: createMockJudge({\n    id: 'judge-007',\n    name: 'Jennifer Anne Parker-Williams',\n    slug: 'jennifer-anne-parker-williams',\n  }),\n\n  judgeWithRomanNumeral: createMockJudge({\n    id: 'judge-008',\n    name: 'Charles Edward Reynolds III',\n    slug: 'charles-edward-reynolds-iii',\n  }),\n\n  judgeWithMiddleName: createMockJudge({\n    id: 'judge-009',\n    name: 'Robert Allen Davis',\n    slug: 'robert-allen-davis',\n  }),\n\n  judgeWithInitialFirst: createMockJudge({\n    id: 'judge-010',\n    name: 'J. Michael Anderson',\n    slug: 'j-michael-anderson',\n  }),\n\n  judgeWithMultipleInitials: createMockJudge({\n    id: 'judge-011',\n    name: 'A. B. C. Washington',\n    slug: 'a-b-c-washington',\n  }),\n\n  judgeWithDoubleSpace: createMockJudge({\n    id: 'judge-012',\n    name: 'Allen  L. Norris', // Double space intentional for testing\n    slug: 'allen-l-norris',\n  }),\n}\n\n/**\n * Judge with low case count for threshold testing\n */\nexport const mockLowCaseCountJudge = createMockJudge({\n  id: 'judge-low-cases',\n  name: 'Sarah Martinez',\n  slug: 'sarah-martinez',\n  total_cases: 320, // Below 500 threshold\n})\n\n/**\n * Get all mock judges including name matching variants\n */\nexport const allMockJudges = [\n  ...mockJudgesList,\n  ...Object.values(mockJudgesForNameMatching),\n  mockLowCaseCountJudge,\n]\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\fixtures\\users.ts",
    "messages": [
      {
        "ruleId": "@typescript-eslint/explicit-function-return-type",
        "severity": 1,
        "message": "Missing return type on function.",
        "line": 55,
        "column": 8,
        "nodeType": "FunctionDeclaration",
        "messageId": "missingReturnType",
        "endLine": 55,
        "endColumn": 31
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Test fixtures for user data\r\n */\r\n\r\nexport const mockUsers = {\r\n  admin: {\r\n    id: 'user-admin-001',\r\n    clerk_id: 'clerk_admin_123',\r\n    email: 'admin@judgefinder.io',\r\n    is_admin: true,\r\n    is_verified_lawyer: false,\r\n    bar_number: null,\r\n    jurisdiction: 'CA',\r\n    created_at: '2024-01-01T00:00:00Z',\r\n    updated_at: '2024-01-01T00:00:00Z',\r\n  },\r\n\r\n  verifiedLawyer: {\r\n    id: 'user-lawyer-001',\r\n    clerk_id: 'clerk_lawyer_456',\r\n    email: 'lawyer@lawfirm.com',\r\n    is_admin: false,\r\n    is_verified_lawyer: true,\r\n    bar_number: 'CA123456',\r\n    jurisdiction: 'CA',\r\n    created_at: '2024-01-01T00:00:00Z',\r\n    updated_at: '2024-01-15T00:00:00Z',\r\n  },\r\n\r\n  regularUser: {\r\n    id: 'user-regular-001',\r\n    clerk_id: 'clerk_user_789',\r\n    email: 'user@example.com',\r\n    is_admin: false,\r\n    is_verified_lawyer: false,\r\n    bar_number: null,\r\n    jurisdiction: 'CA',\r\n    created_at: '2024-01-10T00:00:00Z',\r\n    updated_at: '2024-01-10T00:00:00Z',\r\n  },\r\n\r\n  unverifiedLawyer: {\r\n    id: 'user-lawyer-002',\r\n    clerk_id: 'clerk_lawyer_999',\r\n    email: 'pending@lawfirm.com',\r\n    is_admin: false,\r\n    is_verified_lawyer: false,\r\n    bar_number: 'CA654321',\r\n    jurisdiction: 'CA',\r\n    created_at: '2024-01-20T00:00:00Z',\r\n    updated_at: '2024-01-20T00:00:00Z',\r\n  },\r\n}\r\n\r\nexport function createMockUser(overrides: Partial<typeof mockUsers.regularUser> = {}) {\r\n  return {\r\n    ...mockUsers.regularUser,\r\n    ...overrides,\r\n  }\r\n}\r\n\r\nexport const mockClerkUser = {\r\n  id: 'clerk_user_789',\r\n  emailAddresses: [{ emailAddress: 'user@example.com' }],\r\n  firstName: 'Test',\r\n  lastName: 'User',\r\n  createdAt: new Date('2024-01-10').getTime(),\r\n  updatedAt: new Date('2024-01-10').getTime(),\r\n}\r\n\r\nexport const mockClerkSession = {\r\n  userId: 'clerk_user_789',\r\n  sessionId: 'sess_123abc',\r\n  status: 'active' as const,\r\n}\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\integration\\api\\judges-analytics.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (281). Maximum allowed is 60.",
        "line": 82,
        "column": 45,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 364,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (275). Maximum allowed is 60.",
        "line": 87,
        "column": 46,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 363,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 115,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 115,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3518, 3521], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3518, 3521], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 149,
        "column": 74,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 149,
        "endColumn": 77,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4752, 4755], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4752, 4755], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 167,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 167,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5469, 5472], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5469, 5472], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 223,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 223,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7246, 7249], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7246, 7249], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 306,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 306,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [10165, 10168], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [10165, 10168], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 353,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 353,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [11734, 11737], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [11734, 11737], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 8,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Integration tests for Judge Analytics API endpoint\r\n */\r\n\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\r\nimport { NextRequest } from 'next/server'\r\nimport { GET } from '@/app/api/judges/[id]/analytics/route'\r\nimport { mockJudges } from '@/tests/fixtures/judges'\r\nimport { mockCasesList, generateMockCases } from '@/tests/fixtures/cases'\r\n\r\n// Mock dependencies\r\nvi.mock('@/lib/supabase/server', () => ({\r\n  createServiceRoleClient: vi.fn(async () => ({\r\n    from: vi.fn((table: string) => {\r\n      if (table === 'judges') {\r\n        return {\r\n          select: vi.fn(() => ({\r\n            eq: vi.fn(() => ({\r\n              single: vi.fn(() => ({\r\n                data: mockJudges.activeJudge,\r\n                error: null,\r\n              })),\r\n            })),\r\n          })),\r\n        }\r\n      }\r\n      if (table === 'cases') {\r\n        return {\r\n          select: vi.fn(() => ({\r\n            eq: vi.fn(() => ({\r\n              gte: vi.fn(() => ({\r\n                order: vi.fn(() => ({\r\n                  limit: vi.fn(() => ({\r\n                    data: generateMockCases(50, 'judge-001'),\r\n                    error: null,\r\n                  })),\r\n                })),\r\n              })),\r\n            })),\r\n          })),\r\n        }\r\n      }\r\n      if (table === 'judge_analytics_cache') {\r\n        return {\r\n          select: vi.fn(() => ({\r\n            eq: vi.fn(() => ({\r\n              single: vi.fn(() => ({\r\n                data: null,\r\n                error: { code: 'PGRST116' },\r\n              })),\r\n            })),\r\n          })),\r\n        }\r\n      }\r\n      return {}\r\n    }),\r\n  })),\r\n}))\r\n\r\nvi.mock('@/lib/security/rate-limit', () => ({\r\n  buildRateLimiter: vi.fn(() => ({\r\n    limit: vi.fn(async () => ({ success: true, remaining: 19 })),\r\n  })),\r\n  getClientIp: vi.fn(() => '127.0.0.1'),\r\n}))\r\n\r\nvi.mock('@/lib/cache/redis', () => ({\r\n  redisGetJSON: vi.fn(async () => null),\r\n  redisSetJSON: vi.fn(async () => true),\r\n}))\r\n\r\nvi.mock('@/lib/analytics/enrichment', () => ({\r\n  enrichCasesWithOpinions: vi.fn(async (_supabase, cases) => cases),\r\n}))\r\n\r\nvi.mock('@/lib/analytics/cache', () => ({\r\n  getCachedAnalytics: vi.fn(async () => null),\r\n  cacheAnalytics: vi.fn(async () => true),\r\n  isDataFresh: vi.fn(() => false),\r\n}))\r\n\r\ndescribe('Judge Analytics API Integration', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks()\r\n  })\r\n\r\n  describe('GET /api/judges/[id]/analytics', () => {\r\n    it('should return analytics for judge with cases', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      const response = await GET(request, { params })\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.analytics).toBeDefined()\r\n      expect(data.analytics.confidence_civil).toBeDefined()\r\n      expect(data.document_count).toBeGreaterThan(0)\r\n      expect(data.data_source).toBe('case_analysis')\r\n    })\r\n\r\n    it('should return 404 for non-existent judge', async () => {\r\n      const { createServiceRoleClient } = await import('@/lib/supabase/server')\r\n      vi.mocked(createServiceRoleClient).mockResolvedValue({\r\n        from: vi.fn(() => ({\r\n          select: vi.fn(() => ({\r\n            eq: vi.fn(() => ({\r\n              single: vi.fn(() => ({\r\n                data: null,\r\n                error: { code: 'PGRST116' },\r\n              })),\r\n            })),\r\n          })),\r\n        })),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/non-existent/analytics')\r\n      const params = Promise.resolve({ id: 'non-existent' })\r\n\r\n      const response = await GET(request, { params })\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(404)\r\n      expect(data.error).toContain('Judge not found')\r\n    })\r\n\r\n    it('should use cached analytics if available', async () => {\r\n      const { getCachedAnalytics } = await import('@/lib/analytics/cache')\r\n      const cachedAnalytics = {\r\n        analytics: {\r\n          confidence_civil: 0.92,\r\n          confidence_criminal: 0.88,\r\n          total_cases_analyzed: 100,\r\n          settlement_rate: 0.65,\r\n          dismissal_rate: 0.15,\r\n          avg_case_duration_days: 180,\r\n          case_type_distribution: {},\r\n          temporal_trends: [],\r\n          bias_indicators: {\r\n            consistency_score: 78.5,\r\n            speed_score: 72.3,\r\n            settlement_preference: 15.0,\r\n            risk_tolerance: 45.2,\r\n            predictability_score: 82.1,\r\n          },\r\n        },\r\n        created_at: new Date().toISOString(),\r\n      }\r\n      vi.mocked(getCachedAnalytics).mockResolvedValue(cachedAnalytics as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      const response = await GET(request, { params })\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.cached).toBe(true)\r\n      expect(data.data_source).toBe('database_cache')\r\n      expect(data.analytics).toBeDefined()\r\n    })\r\n\r\n    it('should handle rate limiting', async () => {\r\n      const { buildRateLimiter } = await import('@/lib/security/rate-limit')\r\n      vi.mocked(buildRateLimiter).mockReturnValue({\r\n        limit: vi.fn(async () => ({ success: false, remaining: 0 })),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      const response = await GET(request, { params })\r\n\r\n      expect(response.status).toBe(429)\r\n    })\r\n\r\n    it('should generate analytics from minimal data', async () => {\r\n      const { createServiceRoleClient } = await import('@/lib/supabase/server')\r\n      vi.mocked(createServiceRoleClient).mockResolvedValue({\r\n        from: vi.fn((table: string) => {\r\n          if (table === 'judges') {\r\n            return {\r\n              select: vi.fn(() => ({\r\n                eq: vi.fn(() => ({\r\n                  single: vi.fn(() => ({\r\n                    data: mockJudges.minimalDataJudge,\r\n                    error: null,\r\n                  })),\r\n                })),\r\n              })),\r\n            }\r\n          }\r\n          if (table === 'cases') {\r\n            return {\r\n              select: vi.fn(() => ({\r\n                eq: vi.fn(() => ({\r\n                  gte: vi.fn(() => ({\r\n                    order: vi.fn(() => ({\r\n                      limit: vi.fn(() => ({\r\n                        data: [],\r\n                        error: null,\r\n                      })),\r\n                    })),\r\n                  })),\r\n                })),\r\n              })),\r\n            }\r\n          }\r\n          if (table === 'judge_analytics_cache') {\r\n            return {\r\n              select: vi.fn(() => ({\r\n                eq: vi.fn(() => ({\r\n                  single: vi.fn(() => ({\r\n                    data: null,\r\n                    error: { code: 'PGRST116' },\r\n                  })),\r\n                })),\r\n              })),\r\n            }\r\n          }\r\n          return {}\r\n        }),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-004/analytics')\r\n      const params = Promise.resolve({ id: 'judge-004' })\r\n\r\n      const response = await GET(request, { params })\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.data_source).toBe('profile_estimation')\r\n      expect(data.analytics).toBeDefined()\r\n    })\r\n\r\n    it('should include rate limit remaining in response', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      const response = await GET(request, { params })\r\n      const data = await response.json()\r\n\r\n      expect(data.rate_limit_remaining).toBeDefined()\r\n      expect(typeof data.rate_limit_remaining).toBe('number')\r\n    })\r\n\r\n    it('should cache generated analytics', async () => {\r\n      const { cacheAnalytics } = await import('@/lib/analytics/cache')\r\n      const { redisSetJSON } = await import('@/lib/cache/redis')\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      await GET(request, { params })\r\n\r\n      expect(cacheAnalytics).toHaveBeenCalled()\r\n      expect(redisSetJSON).toHaveBeenCalled()\r\n    })\r\n\r\n    it('should handle database errors during case fetch', async () => {\r\n      const { createServiceRoleClient } = await import('@/lib/supabase/server')\r\n      vi.mocked(createServiceRoleClient).mockResolvedValue({\r\n        from: vi.fn((table: string) => {\r\n          if (table === 'judges') {\r\n            return {\r\n              select: vi.fn(() => ({\r\n                eq: vi.fn(() => ({\r\n                  single: vi.fn(() => ({\r\n                    data: mockJudges.activeJudge,\r\n                    error: null,\r\n                  })),\r\n                })),\r\n              })),\r\n            }\r\n          }\r\n          if (table === 'cases') {\r\n            return {\r\n              select: vi.fn(() => ({\r\n                eq: vi.fn(() => ({\r\n                  gte: vi.fn(() => ({\r\n                    order: vi.fn(() => ({\r\n                      limit: vi.fn(() => ({\r\n                        data: null,\r\n                        error: { message: 'Database error', code: 'DB001' },\r\n                      })),\r\n                    })),\r\n                  })),\r\n                })),\r\n              })),\r\n            }\r\n          }\r\n          if (table === 'judge_analytics_cache') {\r\n            return {\r\n              select: vi.fn(() => ({\r\n                eq: vi.fn(() => ({\r\n                  single: vi.fn(() => ({\r\n                    data: null,\r\n                    error: { code: 'PGRST116' },\r\n                  })),\r\n                })),\r\n              })),\r\n            }\r\n          }\r\n          return {}\r\n        }),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      const response = await GET(request, { params })\r\n      const data = await response.json()\r\n\r\n      // Should still return analytics using fallback method\r\n      expect(response.status).toBe(200)\r\n      expect(data.analytics).toBeDefined()\r\n      expect(data.data_source).toBe('profile_estimation')\r\n    })\r\n\r\n    it('should respect lookback window configuration', async () => {\r\n      const { createServiceRoleClient } = await import('@/lib/supabase/server')\r\n      const selectSpy = vi.fn()\r\n\r\n      vi.mocked(createServiceRoleClient).mockResolvedValue({\r\n        from: vi.fn((table: string) => {\r\n          if (table === 'cases') {\r\n            return {\r\n              select: selectSpy.mockReturnValue({\r\n                eq: vi.fn(() => ({\r\n                  gte: vi.fn(() => ({\r\n                    order: vi.fn(() => ({\r\n                      limit: vi.fn(() => ({\r\n                        data: [],\r\n                        error: null,\r\n                      })),\r\n                    })),\r\n                  })),\r\n                })),\r\n              }),\r\n            }\r\n          }\r\n          return {\r\n            select: vi.fn(() => ({\r\n              eq: vi.fn(() => ({\r\n                single: vi.fn(() => ({\r\n                  data: mockJudges.activeJudge,\r\n                  error: null,\r\n                })),\r\n              })),\r\n            })),\r\n          }\r\n        }),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/judges/judge-001/analytics')\r\n      const params = Promise.resolve({ id: 'judge-001' })\r\n\r\n      await GET(request, { params })\r\n\r\n      // Should select from cases table with date filter\r\n      expect(selectSpy).toHaveBeenCalled()\r\n    })\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\integration\\api\\search.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (163). Maximum allowed is 60.",
        "line": 45,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 210,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (157). Maximum allowed is 60.",
        "line": 50,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 209,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 97,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 97,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3232, 3235], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3232, 3235], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 150,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 150,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5225, 5228], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5225, 5228], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 199,
        "column": 12,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 199,
        "endColumn": 15,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7095, 7098], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7095, 7098], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 5,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Integration tests for Search API endpoint\r\n */\r\n\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\r\nimport { NextRequest } from 'next/server'\r\nimport { GET } from '@/app/api/search/route'\r\nimport { mockJudges, mockJudgesList } from '@/tests/fixtures/judges'\r\n\r\n// Mock dependencies\r\nvi.mock('@/lib/supabase/server', () => ({\r\n  createServerClient: vi.fn(async () => ({\r\n    from: vi.fn(() => ({\r\n      select: vi.fn(() => ({\r\n        order: vi.fn(() => ({\r\n          limit: vi.fn(() => ({\r\n            data: mockJudgesList,\r\n            error: null,\r\n          })),\r\n        })),\r\n        ilike: vi.fn(() => ({\r\n          range: vi.fn(() => ({\r\n            order: vi.fn(() => ({\r\n              data: [mockJudges.activeJudge],\r\n              error: null,\r\n            })),\r\n          })),\r\n        })),\r\n      })),\r\n    })),\r\n  })),\r\n}))\r\n\r\nvi.mock('@/lib/security/rate-limit', () => ({\r\n  buildRateLimiter: vi.fn(() => ({\r\n    limit: vi.fn(async () => ({ success: true, remaining: 59 })),\r\n  })),\r\n  getClientIp: vi.fn(() => '127.0.0.1'),\r\n}))\r\n\r\nvi.mock('@/lib/search/sponsored', () => ({\r\n  fetchSponsoredTiles: vi.fn(async () => []),\r\n}))\r\n\r\ndescribe('Search API Integration', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks()\r\n  })\r\n\r\n  describe('GET /api/search', () => {\r\n    it('should return popular judges when no query provided', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.results).toBeDefined()\r\n      expect(data.total_count).toBeGreaterThan(0)\r\n      expect(data.results_by_type.judges).toBeDefined()\r\n      expect(data.counts_by_type).toBeDefined()\r\n    })\r\n\r\n    it('should search judges by name', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=John+Smith')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.results).toBeDefined()\r\n      expect(data.query).toBe('John Smith')\r\n      expect(data.took_ms).toBeGreaterThanOrEqual(0)\r\n    })\r\n\r\n    it('should filter by judge type', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=Smith&type=judge')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.results_by_type.judges).toBeDefined()\r\n      expect(data.counts_by_type.judges).toBeGreaterThanOrEqual(0)\r\n    })\r\n\r\n    it('should respect limit parameter', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=judge&limit=5')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.results.length).toBeLessThanOrEqual(5)\r\n    })\r\n\r\n    it('should handle rate limiting', async () => {\r\n      const { buildRateLimiter } = await import('@/lib/security/rate-limit')\r\n      vi.mocked(buildRateLimiter).mockReturnValue({\r\n        limit: vi.fn(async () => ({ success: false, remaining: 0 })),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=test')\r\n      const response = await GET(request)\r\n\r\n      expect(response.status).toBe(429)\r\n      const data = await response.json()\r\n      expect(data.error).toContain('Rate limit')\r\n    })\r\n\r\n    it('should sanitize search query', async () => {\r\n      const maliciousQuery = '<script>alert(\"xss\")</script>Judge'\r\n      const request = new NextRequest(\r\n        `http://localhost:3000/api/search?q=${encodeURIComponent(maliciousQuery)}`\r\n      )\r\n      const response = await GET(request)\r\n\r\n      expect(response.status).toBe(200)\r\n      // Should process without executing script\r\n      const data = await response.json()\r\n      expect(JSON.stringify(data)).not.toContain('<script>')\r\n    })\r\n\r\n    it('should return cache headers', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=test')\r\n      const response = await GET(request)\r\n\r\n      expect(response.headers.has('Cache-Control')).toBe(true)\r\n      expect(response.headers.get('Cache-Control')).toContain('max-age')\r\n    })\r\n\r\n    it('should include rate limit remaining in response', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=test')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(data.rate_limit_remaining).toBeDefined()\r\n      expect(typeof data.rate_limit_remaining).toBe('number')\r\n    })\r\n\r\n    it('should handle database errors gracefully', async () => {\r\n      const { createServerClient } = await import('@/lib/supabase/server')\r\n      vi.mocked(createServerClient).mockResolvedValue({\r\n        from: vi.fn(() => ({\r\n          select: vi.fn(() => ({\r\n            order: vi.fn(() => ({\r\n              limit: vi.fn(() => ({\r\n                data: null,\r\n                error: { message: 'Database error', code: 'DB001' },\r\n              })),\r\n            })),\r\n          })),\r\n        })),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/search')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      // Should still return 200 with empty results\r\n      expect(response.status).toBe(200)\r\n      expect(data.results).toBeDefined()\r\n    })\r\n\r\n    it('should return suggestions when requested', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=judge&suggestions=true')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.suggestions).toBeDefined()\r\n    })\r\n\r\n    it('should search across multiple entity types', async () => {\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=california&type=all')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      expect(data.results_by_type).toHaveProperty('judges')\r\n      expect(data.results_by_type).toHaveProperty('courts')\r\n      expect(data.results_by_type).toHaveProperty('jurisdictions')\r\n    })\r\n\r\n    it('should prioritize exact matches', async () => {\r\n      const { createServerClient } = await import('@/lib/supabase/server')\r\n      const exactMatch = { ...mockJudges.activeJudge, name: 'John Smith' }\r\n      const partialMatch = { ...mockJudges.retiredJudge, name: 'John Smithson' }\r\n\r\n      vi.mocked(createServerClient).mockResolvedValue({\r\n        from: vi.fn(() => ({\r\n          select: vi.fn(() => ({\r\n            ilike: vi.fn(() => ({\r\n              range: vi.fn(() => ({\r\n                order: vi.fn(() => ({\r\n                  data: [exactMatch, partialMatch],\r\n                  error: null,\r\n                })),\r\n              })),\r\n            })),\r\n          })),\r\n        })),\r\n      } as any)\r\n\r\n      const request = new NextRequest('http://localhost:3000/api/search?q=John+Smith')\r\n      const response = await GET(request)\r\n      const data = await response.json()\r\n\r\n      expect(response.status).toBe(200)\r\n      // Exact match should be first\r\n      expect(data.results[0].title).toBe('John Smith')\r\n    })\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\lib\\courtlistener\\global-rate-limiter.manual.test.js",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Async function 'runTests' has too many lines (228). Maximum allowed is 60.",
        "line": 13,
        "column": 1,
        "nodeType": "FunctionDeclaration",
        "messageId": "exceed",
        "endLine": 246,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Manual Test Suite for Global Rate Limiter\r\n *\r\n * Run with: node tests/lib/courtlistener/global-rate-limiter.manual.test.js\r\n */\r\n\r\nconst assert = require('assert')\r\n\r\n// Mock environment for testing\r\nprocess.env.UPSTASH_REDIS_REST_URL = process.env.UPSTASH_REDIS_REST_URL || 'http://test-redis.example.com'\r\nprocess.env.UPSTASH_REDIS_REST_TOKEN = process.env.UPSTASH_REDIS_REST_TOKEN || 'test-token'\r\n\r\nasync function runTests() {\r\n  console.log('🧪 Starting Global Rate Limiter Manual Tests\\n')\r\n\r\n  let passedTests = 0\r\n  let failedTests = 0\r\n\r\n  const tests = [\r\n    {\r\n      name: 'Rate limiter can be imported',\r\n      async test() {\r\n        // Since we're using TypeScript, we'll just verify the file exists\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const filePath = path.join(__dirname, '../../../lib/courtlistener/global-rate-limiter.ts')\r\n        assert(fs.existsSync(filePath), 'Rate limiter file should exist')\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Rate limiter exports expected interfaces',\r\n      async test() {\r\n        // Verify TypeScript compilation\r\n        const { execSync } = require('child_process')\r\n        try {\r\n          execSync('npx tsc --noEmit lib/courtlistener/global-rate-limiter.ts', {\r\n            cwd: path.join(__dirname, '../../..'),\r\n            stdio: 'pipe'\r\n          })\r\n          // If it compiles without error, we're good\r\n        } catch (error) {\r\n          // Only fail if it's a real compilation error, not other TS errors\r\n          if (error.message.includes('global-rate-limiter.ts')) {\r\n            throw new Error('Rate limiter has TypeScript compilation errors')\r\n          }\r\n        }\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Documentation files exist',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n\r\n        const docs = [\r\n          '../../../docs/RATE_LIMITER_INTEGRATION.md',\r\n          '../../../docs/RATE_LIMITER_IMPLEMENTATION_SUMMARY.md'\r\n        ]\r\n\r\n        docs.forEach(doc => {\r\n          const docPath = path.join(__dirname, doc)\r\n          assert(fs.existsSync(docPath), `${doc} should exist`)\r\n        })\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Admin API endpoint exists',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const apiPath = path.join(__dirname, '../../../app/api/admin/rate-limit/route.ts')\r\n        assert(fs.existsSync(apiPath), 'Admin API endpoint should exist')\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Redis key constants are properly defined',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const filePath = path.join(__dirname, '../../../lib/courtlistener/global-rate-limiter.ts')\r\n        const content = fs.readFileSync(filePath, 'utf8')\r\n\r\n        const requiredConstants = [\r\n          'RATE_LIMIT_KEY',\r\n          'RATE_LIMIT_WINDOW_KEY',\r\n          'USAGE_STATS_KEY',\r\n          'ALERT_SENT_KEY',\r\n          'HOURLY_LIMIT',\r\n          'BUFFER_LIMIT',\r\n          'WARNING_THRESHOLD'\r\n        ]\r\n\r\n        requiredConstants.forEach(constant => {\r\n          assert(\r\n            content.includes(constant),\r\n            `Should define constant: ${constant}`\r\n          )\r\n        })\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'GlobalRateLimiter class has all required methods',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const filePath = path.join(__dirname, '../../../lib/courtlistener/global-rate-limiter.ts')\r\n        const content = fs.readFileSync(filePath, 'utf8')\r\n\r\n        const requiredMethods = [\r\n          'checkLimit',\r\n          'recordRequest',\r\n          'waitForAvailability',\r\n          'getUsageStats',\r\n          'getRemainingRequests',\r\n          'getResetTime',\r\n          'isRateLimited',\r\n          'getStatusReport',\r\n          'resetWindow'\r\n        ]\r\n\r\n        requiredMethods.forEach(method => {\r\n          assert(\r\n            content.includes(`async ${method}`) || content.includes(`${method}(`),\r\n            `Should define method: ${method}`\r\n          )\r\n        })\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Helper functions are exported',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const filePath = path.join(__dirname, '../../../lib/courtlistener/global-rate-limiter.ts')\r\n        const content = fs.readFileSync(filePath, 'utf8')\r\n\r\n        const helperFunctions = [\r\n          'getGlobalRateLimiter',\r\n          'withRateLimitProtection'\r\n        ]\r\n\r\n        helperFunctions.forEach(fn => {\r\n          assert(\r\n            content.includes(`export function ${fn}`) || content.includes(`export async function ${fn}`),\r\n            `Should export helper function: ${fn}`\r\n          )\r\n        })\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Integration documentation is comprehensive',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const docPath = path.join(__dirname, '../../../docs/RATE_LIMITER_INTEGRATION.md')\r\n        const content = fs.readFileSync(docPath, 'utf8')\r\n\r\n        const requiredSections = [\r\n          'Overview',\r\n          'Architecture',\r\n          'Redis Key Schema',\r\n          'Integration Instructions',\r\n          'Usage Examples',\r\n          'Monitoring',\r\n          'Testing',\r\n          'Troubleshooting'\r\n        ]\r\n\r\n        requiredSections.forEach(section => {\r\n          assert(\r\n            content.includes(section),\r\n            `Documentation should include section: ${section}`\r\n          )\r\n        })\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'Admin API has GET and POST handlers',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const apiPath = path.join(__dirname, '../../../app/api/admin/rate-limit/route.ts')\r\n        const content = fs.readFileSync(apiPath, 'utf8')\r\n\r\n        assert(content.includes('export async function GET'), 'Should have GET handler')\r\n        assert(content.includes('export async function POST'), 'Should have POST handler')\r\n        assert(content.includes('getGlobalRateLimiter'), 'Should use rate limiter')\r\n      }\r\n    },\r\n\r\n    {\r\n      name: 'TypeScript types are properly defined',\r\n      async test() {\r\n        const fs = require('fs')\r\n        const path = require('path')\r\n        const filePath = path.join(__dirname, '../../../lib/courtlistener/global-rate-limiter.ts')\r\n        const content = fs.readFileSync(filePath, 'utf8')\r\n\r\n        const requiredTypes = [\r\n          'RateLimitResult',\r\n          'UsageStats',\r\n          'RateLimitConfig'\r\n        ]\r\n\r\n        requiredTypes.forEach(type => {\r\n          assert(\r\n            content.includes(`interface ${type}`) || content.includes(`export interface ${type}`),\r\n            `Should define type: ${type}`\r\n          )\r\n        })\r\n      }\r\n    }\r\n  ]\r\n\r\n  // Run all tests\r\n  for (const test of tests) {\r\n    try {\r\n      await test.test()\r\n      console.log(`✅ ${test.name}`)\r\n      passedTests++\r\n    } catch (error) {\r\n      console.error(`❌ ${test.name}`)\r\n      console.error(`   ${error.message}\\n`)\r\n      failedTests++\r\n    }\r\n  }\r\n\r\n  // Summary\r\n  console.log('\\n' + '='.repeat(60))\r\n  console.log(`Test Results: ${passedTests} passed, ${failedTests} failed`)\r\n  console.log('='.repeat(60))\r\n\r\n  if (failedTests > 0) {\r\n    process.exit(1)\r\n  } else {\r\n    console.log('\\n✨ All tests passed!')\r\n  }\r\n}\r\n\r\n// Run tests if this file is executed directly\r\nif (require.main === module) {\r\n  runTests().catch(error => {\r\n    console.error('Test suite failed:', error)\r\n    process.exit(1)\r\n  })\r\n}\r\n\r\nmodule.exports = { runTests }\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\performance\\load-test.js",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\setup\\test-setup.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\smoke\\production.spec.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (260). Maximum allowed is 60.",
        "line": 19,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 301,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Production Smoke Tests\r\n *\r\n * Critical user flows that must work in production.\r\n * Run these tests after every deployment to verify core functionality.\r\n *\r\n * Usage:\r\n *   npx playwright test tests/smoke/production.spec.ts\r\n *   PROD_URL=https://judgefinder.io npx playwright test tests/smoke/production.spec.ts\r\n */\r\n\r\nimport { test, expect } from '@playwright/test'\r\n\r\n// Configuration\r\nconst PROD_URL = process.env.PROD_URL || process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3005'\r\nconst MAX_LOAD_TIME = 3000 // 3 seconds\r\nconst API_TIMEOUT = 5000 // 5 seconds\r\n\r\ntest.describe('Production Smoke Tests', () => {\r\n  test.beforeEach(async ({ page }) => {\r\n    // Set up console error tracking\r\n    page.on('console', msg => {\r\n      if (msg.type() === 'error') {\r\n        console.error('Console error:', msg.text())\r\n      }\r\n    })\r\n\r\n    // Track page errors\r\n    page.on('pageerror', error => {\r\n      console.error('Page error:', error)\r\n    })\r\n  })\r\n\r\n  test.describe('Critical Page Loads', () => {\r\n    test('homepage loads within 3 seconds', async ({ page }) => {\r\n      const startTime = Date.now()\r\n\r\n      await page.goto(PROD_URL, { waitUntil: 'networkidle' })\r\n\r\n      const loadTime = Date.now() - startTime\r\n      expect(loadTime).toBeLessThan(MAX_LOAD_TIME)\r\n\r\n      // Verify page title\r\n      await expect(page).toHaveTitle(/JudgeFinder/i)\r\n\r\n      // Verify key elements are present\r\n      await expect(page.locator('body')).toBeVisible()\r\n\r\n      console.log(`Homepage loaded in ${loadTime}ms`)\r\n    })\r\n\r\n    test('search page loads successfully', async ({ page }) => {\r\n      await page.goto(`${PROD_URL}/search`, { waitUntil: 'networkidle' })\r\n\r\n      // Verify search interface is present\r\n      await expect(page.locator('input[type=\"search\"], input[placeholder*=\"search\" i]')).toBeVisible({ timeout: 5000 })\r\n\r\n      // No JavaScript errors should be logged\r\n      const errors: string[] = []\r\n      page.on('pageerror', error => errors.push(error.message))\r\n\r\n      await page.waitForTimeout(1000)\r\n      expect(errors.length).toBe(0)\r\n    })\r\n\r\n    test('courts page loads successfully', async ({ page }) => {\r\n      await page.goto(`${PROD_URL}/courts`, { waitUntil: 'networkidle' })\r\n\r\n      // Verify courts list or content is present\r\n      await expect(page.locator('body')).toContainText(/court/i)\r\n\r\n      // Check for proper rendering\r\n      const hasContent = await page.locator('main, [role=\"main\"]').isVisible()\r\n      expect(hasContent).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  test.describe('Search Functionality', () => {\r\n    test('search returns results', async ({ page }) => {\r\n      await page.goto(PROD_URL)\r\n\r\n      // Find search input (adjust selector based on your implementation)\r\n      const searchInput = page.locator('input[type=\"search\"], input[placeholder*=\"search\" i]').first()\r\n\r\n      if (await searchInput.isVisible({ timeout: 2000 }).catch(() => false)) {\r\n        await searchInput.fill('judge')\r\n        await searchInput.press('Enter')\r\n\r\n        // Wait for results to load\r\n        await page.waitForLoadState('networkidle')\r\n\r\n        // Verify results are displayed (adjust selector based on your implementation)\r\n        const hasResults = await page.locator('[data-testid=\"search-results\"], .search-results, main').isVisible()\r\n        expect(hasResults).toBeTruthy()\r\n      } else {\r\n        console.log('Search input not found on homepage, skipping search test')\r\n      }\r\n    })\r\n\r\n    test('search handles no results gracefully', async ({ page }) => {\r\n      await page.goto(`${PROD_URL}/search?q=zzznonexistentquery123456`)\r\n\r\n      await page.waitForLoadState('networkidle')\r\n\r\n      // Should show no results message, not an error\r\n      const bodyText = await page.locator('body').textContent()\r\n      expect(bodyText).not.toContain('Error')\r\n      expect(bodyText).not.toContain('500')\r\n      expect(bodyText).not.toContain('Internal Server Error')\r\n    })\r\n  })\r\n\r\n  test.describe('API Health Checks', () => {\r\n    test('health endpoint responds correctly', async ({ request }) => {\r\n      const response = await request.get(`${PROD_URL}/api/health`, {\r\n        timeout: API_TIMEOUT\r\n      })\r\n\r\n      expect(response.ok()).toBeTruthy()\r\n      expect(response.status()).toBe(200)\r\n\r\n      const data = await response.json()\r\n      expect(data.status).toMatch(/healthy|degraded/)\r\n      expect(data.checks).toBeDefined()\r\n      expect(data.performance).toBeDefined()\r\n    })\r\n\r\n    test('search API responds', async ({ request }) => {\r\n      const response = await request.get(`${PROD_URL}/api/search?q=test`, {\r\n        timeout: API_TIMEOUT\r\n      })\r\n\r\n      expect(response.ok()).toBeTruthy()\r\n      expect(response.status()).toBe(200)\r\n\r\n      const data = await response.json()\r\n      expect(data).toBeDefined()\r\n    })\r\n\r\n    test('courts API responds', async ({ request }) => {\r\n      const response = await request.get(`${PROD_URL}/api/courts`, {\r\n        timeout: API_TIMEOUT\r\n      })\r\n\r\n      expect(response.ok()).toBeTruthy()\r\n      expect(response.status()).toBe(200)\r\n\r\n      const data = await response.json()\r\n      expect(Array.isArray(data)).toBeTruthy()\r\n    })\r\n  })\r\n\r\n  test.describe('SEO & Metadata', () => {\r\n    test('sitemap is accessible', async ({ request }) => {\r\n      const response = await request.get(`${PROD_URL}/sitemap.xml`)\r\n\r\n      expect(response.ok()).toBeTruthy()\r\n      expect(response.status()).toBe(200)\r\n\r\n      const text = await response.text()\r\n      expect(text).toContain('<?xml')\r\n      expect(text).toContain('urlset')\r\n    })\r\n\r\n    test('robots.txt is accessible', async ({ request }) => {\r\n      const response = await request.get(`${PROD_URL}/robots.txt`)\r\n\r\n      expect(response.ok()).toBeTruthy()\r\n      expect(response.status()).toBe(200)\r\n\r\n      const text = await response.text()\r\n      expect(text).toContain('User-agent')\r\n    })\r\n\r\n    test('homepage has proper meta tags', async ({ page }) => {\r\n      await page.goto(PROD_URL)\r\n\r\n      // Check for essential meta tags\r\n      const metaDescription = await page.locator('meta[name=\"description\"]').getAttribute('content')\r\n      expect(metaDescription).toBeTruthy()\r\n      expect(metaDescription!.length).toBeGreaterThan(50)\r\n\r\n      // Check for Open Graph tags\r\n      const ogTitle = await page.locator('meta[property=\"og:title\"]').getAttribute('content')\r\n      expect(ogTitle).toBeTruthy()\r\n\r\n      // Check canonical URL\r\n      const canonical = page.locator('link[rel=\"canonical\"]')\r\n      if (await canonical.count() > 0) {\r\n        const href = await canonical.getAttribute('href')\r\n        expect(href).toContain(PROD_URL)\r\n      }\r\n    })\r\n  })\r\n\r\n  test.describe('Security Headers', () => {\r\n    test('security headers are present', async ({ request }) => {\r\n      const response = await request.get(PROD_URL)\r\n\r\n      const headers = response.headers()\r\n\r\n      // Check for important security headers\r\n      expect(headers['x-frame-options']).toBeDefined()\r\n      expect(headers['x-content-type-options']).toBe('nosniff')\r\n      expect(headers['referrer-policy']).toBeDefined()\r\n    })\r\n  })\r\n\r\n  test.describe('Error Handling', () => {\r\n    test('404 page renders correctly', async ({ page }) => {\r\n      const response = await page.goto(`${PROD_URL}/this-page-does-not-exist-12345`, {\r\n        waitUntil: 'networkidle'\r\n      })\r\n\r\n      expect(response?.status()).toBe(404)\r\n\r\n      // Should show 404 message, not a blank page or error\r\n      const bodyText = await page.locator('body').textContent()\r\n      expect(bodyText).toMatch(/404|not found/i)\r\n    })\r\n\r\n    test('no JavaScript errors on homepage', async ({ page }) => {\r\n      const errors: string[] = []\r\n\r\n      page.on('pageerror', error => {\r\n        errors.push(error.message)\r\n      })\r\n\r\n      page.on('console', msg => {\r\n        if (msg.type() === 'error') {\r\n          errors.push(msg.text())\r\n        }\r\n      })\r\n\r\n      await page.goto(PROD_URL, { waitUntil: 'networkidle' })\r\n      await page.waitForTimeout(2000)\r\n\r\n      // Filter out expected errors (if any)\r\n      const criticalErrors = errors.filter(error => {\r\n        // Add patterns for expected/acceptable errors here\r\n        return !error.includes('ResizeObserver') // Common false positive\r\n      })\r\n\r\n      if (criticalErrors.length > 0) {\r\n        console.error('JavaScript errors detected:', criticalErrors)\r\n      }\r\n\r\n      expect(criticalErrors.length).toBe(0)\r\n    })\r\n  })\r\n\r\n  test.describe('Performance Metrics', () => {\r\n    test('homepage loads within acceptable time', async ({ page }) => {\r\n      const metrics = await page.evaluate(() => {\r\n        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming\r\n        return {\r\n          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\r\n          loadComplete: navigation.loadEventEnd - navigation.loadEventStart,\r\n          domInteractive: navigation.domInteractive - navigation.fetchStart,\r\n        }\r\n      })\r\n\r\n      await page.goto(PROD_URL, { waitUntil: 'load' })\r\n\r\n      console.log('Performance metrics:', metrics)\r\n\r\n      // DOM should be interactive within 2 seconds\r\n      expect(metrics.domInteractive).toBeLessThan(2000)\r\n    })\r\n\r\n    test('API responses are fast', async ({ request }) => {\r\n      const startTime = Date.now()\r\n\r\n      await request.get(`${PROD_URL}/api/health`)\r\n\r\n      const responseTime = Date.now() - startTime\r\n\r\n      console.log(`Health check response time: ${responseTime}ms`)\r\n\r\n      // Health check should respond in under 1 second\r\n      expect(responseTime).toBeLessThan(1000)\r\n    })\r\n  })\r\n\r\n  test.describe('Mobile Responsiveness', () => {\r\n    test('homepage is mobile-friendly', async ({ page }) => {\r\n      await page.setViewportSize({ width: 375, height: 667 }) // iPhone SE size\r\n\r\n      await page.goto(PROD_URL)\r\n\r\n      // Page should be visible and not horizontally scrollable\r\n      const bodyWidth = await page.evaluate(() => document.body.scrollWidth)\r\n      const viewportWidth = await page.evaluate(() => window.innerWidth)\r\n\r\n      expect(bodyWidth).toBeLessThanOrEqual(viewportWidth + 1) // +1 for rounding\r\n\r\n      // Essential elements should be visible on mobile\r\n      await expect(page.locator('body')).toBeVisible()\r\n    })\r\n  })\r\n})\r\n\r\n// Test configuration\r\ntest.describe.configure({ mode: 'parallel', timeout: 30000 })\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\analytics\\bias-calculations.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (494). Maximum allowed is 60.",
        "line": 14,
        "column": 31,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 508,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (98). Maximum allowed is 60.",
        "line": 172,
        "column": 39,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 270,
        "endColumn": 4
      },
      {
        "ruleId": "id-length",
        "severity": 1,
        "message": "Identifier name '_' is too short (< 2).",
        "line": 276,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "tooShort",
        "endLine": 276,
        "endColumn": 16
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (65). Maximum allowed is 60.",
        "line": 310,
        "column": 54,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 374,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for bias calculation functions\n */\n\nimport { describe, it, expect } from 'vitest'\nimport {\n  analyzeCaseTypePatterns,\n  analyzeOutcomes,\n  analyzeTemporalPatterns,\n  calculateBiasIndicators,\n  type CaseRecord,\n} from '@/lib/analytics/bias-calculations'\n\ndescribe('Bias Calculations', () => {\n  describe('analyzeCaseTypePatterns', () => {\n    it('should analyze case type patterns correctly', () => {\n      const cases: CaseRecord[] = [\n        { case_type: 'Civil', outcome: 'Settled', case_value: 100000 },\n        { case_type: 'Civil', outcome: 'Dismissed', case_value: 50000 },\n        { case_type: 'Civil', outcome: 'Settled', case_value: 200000 },\n        { case_type: 'Criminal', outcome: 'Judgment', case_value: null },\n        { case_type: 'Criminal', outcome: 'Dismissed', case_value: null },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n\n      expect(patterns).toHaveLength(2)\n      expect(patterns[0].case_type).toBe('Civil')\n      expect(patterns[0].total_cases).toBe(3)\n      expect(patterns[0].settlement_rate).toBeCloseTo(0.667, 2)\n      expect(patterns[0].average_case_value).toBeCloseTo(116666.67, 2)\n      expect(patterns[0].outcome_distribution.settled).toBe(2)\n      expect(patterns[0].outcome_distribution.dismissed).toBe(1)\n    })\n\n    it('should handle empty case list', () => {\n      const patterns = analyzeCaseTypePatterns([])\n      expect(patterns).toEqual([])\n    })\n\n    it('should sort by total cases descending', () => {\n      const cases: CaseRecord[] = [\n        { case_type: 'Family', outcome: 'Settled' },\n        { case_type: 'Civil', outcome: 'Settled' },\n        { case_type: 'Civil', outcome: 'Dismissed' },\n        { case_type: 'Civil', outcome: 'Judgment' },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n\n      expect(patterns[0].case_type).toBe('Civil')\n      expect(patterns[0].total_cases).toBe(3)\n      expect(patterns[1].case_type).toBe('Family')\n      expect(patterns[1].total_cases).toBe(1)\n    })\n\n    it('should handle cases with null/undefined values', () => {\n      const cases: CaseRecord[] = [\n        { case_type: null, outcome: 'Settled', case_value: null },\n        { case_type: 'Civil', outcome: null, case_value: undefined },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n\n      expect(patterns).toHaveLength(2)\n      expect(patterns.some((p) => p.case_type === 'Other')).toBe(true)\n      expect(patterns.some((p) => p.case_type === 'Civil')).toBe(true)\n    })\n  })\n\n  describe('analyzeOutcomes', () => {\n    it('should calculate outcome rates correctly', () => {\n      const cases: CaseRecord[] = [\n        { outcome: 'Settled', filing_date: '2023-01-01', decision_date: '2023-03-01' },\n        { outcome: 'Settled', filing_date: '2023-02-01', decision_date: '2023-04-01' },\n        { outcome: 'Dismissed', filing_date: '2023-01-15', decision_date: '2023-02-15' },\n        { outcome: 'Judgment', filing_date: '2023-03-01', decision_date: '2023-05-01' },\n      ]\n\n      const analysis = analyzeOutcomes(cases)\n\n      expect(analysis.overall_settlement_rate).toBe(0.5)\n      expect(analysis.dismissal_rate).toBe(0.25)\n      expect(analysis.judgment_rate).toBe(0.25)\n      expect(analysis.average_case_duration).toBeGreaterThan(0)\n    })\n\n    it('should calculate case value trends', () => {\n      const cases: CaseRecord[] = [\n        { case_value: 5000, outcome: 'Settled' },\n        { case_value: 25000, outcome: 'Settled' },\n        { case_value: 150000, outcome: 'Dismissed' },\n        { case_value: 500000, outcome: 'Judgment' },\n      ]\n\n      const analysis = analyzeOutcomes(cases)\n\n      expect(analysis.case_value_trends).toHaveLength(4)\n      expect(analysis.case_value_trends[0].value_range).toBe('< $10K')\n      expect(analysis.case_value_trends[0].case_count).toBe(1)\n      expect(analysis.case_value_trends[1].value_range).toBe('$10K - $50K')\n      expect(analysis.case_value_trends[2].value_range).toBe('$50K - $250K')\n      expect(analysis.case_value_trends[3].value_range).toBe('$250K+')\n    })\n\n    it('should handle cases without dates', () => {\n      const cases: CaseRecord[] = [{ outcome: 'Settled' }, { outcome: 'Dismissed' }]\n\n      const analysis = analyzeOutcomes(cases)\n\n      expect(analysis.overall_settlement_rate).toBe(0.5)\n      expect(analysis.average_case_duration).toBe(0)\n    })\n  })\n\n  describe('analyzeTemporalPatterns', () => {\n    it('should group cases by month', () => {\n      const cases: CaseRecord[] = [\n        { decision_date: '2023-01-15', outcome: 'Settled', filing_date: '2022-12-01' },\n        { decision_date: '2023-01-20', outcome: 'Dismissed', filing_date: '2023-01-01' },\n        { decision_date: '2023-02-10', outcome: 'Settled', filing_date: '2023-01-15' },\n      ]\n\n      const patterns = analyzeTemporalPatterns(cases)\n\n      expect(patterns).toHaveLength(2)\n      expect(patterns[0].year).toBe(2023)\n      expect(patterns[0].month).toBe(1)\n      expect(patterns[0].case_count).toBe(2)\n      expect(patterns[0].settlement_rate).toBe(0.5)\n    })\n\n    it('should sort patterns chronologically', () => {\n      const cases: CaseRecord[] = [\n        { decision_date: '2023-03-15', outcome: 'Settled' },\n        { decision_date: '2023-01-20', outcome: 'Dismissed' },\n        { decision_date: '2023-02-10', outcome: 'Settled' },\n      ]\n\n      const patterns = analyzeTemporalPatterns(cases)\n\n      expect(patterns[0].month).toBe(1)\n      expect(patterns[1].month).toBe(2)\n      expect(patterns[2].month).toBe(3)\n    })\n\n    it('should calculate average duration', () => {\n      const cases: CaseRecord[] = [\n        { decision_date: '2023-03-01', filing_date: '2023-01-01', outcome: 'Settled' },\n        { decision_date: '2023-03-15', filing_date: '2023-02-01', outcome: 'Dismissed' },\n      ]\n\n      const patterns = analyzeTemporalPatterns(cases)\n\n      expect(patterns[0].average_duration).toBeGreaterThan(0)\n    })\n\n    it('should ignore invalid dates', () => {\n      const cases: CaseRecord[] = [\n        { decision_date: 'invalid-date', outcome: 'Settled' },\n        { decision_date: null, outcome: 'Dismissed' },\n        { decision_date: '2023-03-15', outcome: 'Settled' },\n      ]\n\n      const patterns = analyzeTemporalPatterns(cases)\n\n      expect(patterns).toHaveLength(1)\n      expect(patterns[0].case_count).toBe(1)\n    })\n  })\n\n  describe('calculateBiasIndicators', () => {\n    it('should calculate bias indicators within valid ranges', () => {\n      const cases: CaseRecord[] = [\n        {\n          case_type: 'Civil',\n          outcome: 'Settled',\n          case_value: 100000,\n          filing_date: '2023-01-01',\n          decision_date: '2023-03-01',\n        },\n        {\n          case_type: 'Civil',\n          outcome: 'Settled',\n          case_value: 150000,\n          filing_date: '2023-02-01',\n          decision_date: '2023-04-01',\n        },\n        {\n          case_type: 'Criminal',\n          outcome: 'Judgment',\n          filing_date: '2023-01-15',\n          decision_date: '2023-02-15',\n        },\n      ]\n\n      const caseTypePatterns = analyzeCaseTypePatterns(cases)\n      const outcomeAnalysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, caseTypePatterns, outcomeAnalysis)\n\n      expect(indicators.consistency_score).toBeGreaterThanOrEqual(0)\n      expect(indicators.consistency_score).toBeLessThanOrEqual(100)\n      expect(indicators.speed_score).toBeGreaterThanOrEqual(0)\n      expect(indicators.speed_score).toBeLessThanOrEqual(100)\n      expect(indicators.settlement_preference).toBeGreaterThanOrEqual(-50)\n      expect(indicators.settlement_preference).toBeLessThanOrEqual(50)\n      expect(indicators.risk_tolerance).toBeGreaterThanOrEqual(0)\n      expect(indicators.risk_tolerance).toBeLessThanOrEqual(100)\n      expect(indicators.predictability_score).toBeGreaterThanOrEqual(0)\n      expect(indicators.predictability_score).toBeLessThanOrEqual(100)\n    })\n\n    it('should handle edge case with single case', () => {\n      const cases: CaseRecord[] = [\n        {\n          case_type: 'Civil',\n          outcome: 'Settled',\n          case_value: 50000,\n          filing_date: '2023-01-01',\n          decision_date: '2023-02-01',\n        },\n      ]\n\n      const caseTypePatterns = analyzeCaseTypePatterns(cases)\n      const outcomeAnalysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, caseTypePatterns, outcomeAnalysis)\n\n      expect(indicators.consistency_score).toBeGreaterThanOrEqual(0)\n      expect(indicators.predictability_score).toBeLessThan(100) // Should be penalized for low sample\n    })\n\n    it('should calculate settlement preference correctly', () => {\n      const highSettlementCases: CaseRecord[] = Array(10)\n        .fill(null)\n        .map(() => ({ outcome: 'Settled' }))\n\n      const caseTypePatterns = analyzeCaseTypePatterns(highSettlementCases)\n      const outcomeAnalysis = analyzeOutcomes(highSettlementCases)\n      const indicators = calculateBiasIndicators(\n        highSettlementCases,\n        caseTypePatterns,\n        outcomeAnalysis\n      )\n\n      expect(indicators.settlement_preference).toBeGreaterThan(0) // Positive preference\n    })\n\n    it('should return fixed decimal precision', () => {\n      const cases: CaseRecord[] = [\n        {\n          case_type: 'Civil',\n          outcome: 'Settled',\n          case_value: 100000,\n          filing_date: '2023-01-01',\n          decision_date: '2023-03-01',\n        },\n      ]\n\n      const caseTypePatterns = analyzeCaseTypePatterns(cases)\n      const outcomeAnalysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, caseTypePatterns, outcomeAnalysis)\n\n      // Check all values have at most 1 decimal place\n      expect(Number.isInteger(indicators.consistency_score * 10)).toBe(true)\n      expect(Number.isInteger(indicators.speed_score * 10)).toBe(true)\n      expect(Number.isInteger(indicators.settlement_preference * 10)).toBe(true)\n      expect(Number.isInteger(indicators.risk_tolerance * 10)).toBe(true)\n      expect(Number.isInteger(indicators.predictability_score * 10)).toBe(true)\n    })\n  })\n\n  describe('Edge Cases - Sample Size < 500', () => {\n    it('should handle dataset below minimum threshold (< 500 cases)', () => {\n      const cases: CaseRecord[] = Array(350)\n        .fill(null)\n        .map((_, i) => ({\n          case_type: 'Civil',\n          outcome: i % 2 === 0 ? 'Settled' : 'Judgment',\n          case_value: 50000,\n        }))\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      const analysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, patterns, analysis)\n\n      expect(patterns[0].total_cases).toBe(350)\n      expect(indicators.predictability_score).toBeLessThan(100)\n    })\n\n    it('should handle very small dataset (< 50 cases)', () => {\n      const cases: CaseRecord[] = Array(25)\n        .fill(null)\n        .map(() => ({ case_type: 'Civil', outcome: 'Settled' }))\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      expect(patterns[0].total_cases).toBe(25)\n    })\n\n    it('should handle single case dataset', () => {\n      const cases: CaseRecord[] = [{ case_type: 'Civil', outcome: 'Settled' }]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      const analysis = analyzeOutcomes(cases)\n\n      expect(patterns).toHaveLength(1)\n      expect(analysis.overall_settlement_rate).toBe(1)\n    })\n  })\n\n  describe('Edge Cases - Outliers and Missing Data', () => {\n    it('should handle cases with extreme case values', () => {\n      const cases: CaseRecord[] = [\n        { case_value: 1000000000, outcome: 'Settled' }, // 1 billion\n        { case_value: 1, outcome: 'Settled' }, // 1 dollar\n        { case_value: 50000, outcome: 'Judgment' },\n      ]\n\n      const analysis = analyzeOutcomes(cases)\n      expect(analysis.case_value_trends).toHaveLength(4)\n      expect(analysis.case_value_trends[3].case_count).toBe(1) // Billion dollar case\n    })\n\n    it('should handle cases with all null case values', () => {\n      const cases: CaseRecord[] = [\n        { case_type: 'Criminal', case_value: null, outcome: 'Judgment' },\n        { case_type: 'Criminal', case_value: null, outcome: 'Dismissed' },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      expect(patterns[0].average_case_value).toBe(0)\n    })\n\n    it('should handle cases with all missing outcomes', () => {\n      const cases: CaseRecord[] = [\n        { case_type: 'Civil', outcome: null },\n        { case_type: 'Civil', outcome: undefined },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      expect(patterns[0].outcome_distribution.other).toBe(2)\n    })\n\n    it('should handle cases with all missing dates', () => {\n      const cases: CaseRecord[] = [\n        { outcome: 'Settled', filing_date: null, decision_date: null },\n        { outcome: 'Dismissed', filing_date: undefined, decision_date: undefined },\n      ]\n\n      const patterns = analyzeTemporalPatterns(cases)\n      expect(patterns).toEqual([])\n    })\n\n    it('should handle invalid date formats', () => {\n      const cases: CaseRecord[] = [\n        { outcome: 'Settled', decision_date: '2023-13-45' }, // Invalid date\n        { outcome: 'Dismissed', decision_date: 'not-a-date' },\n        { outcome: 'Judgment', decision_date: '' },\n      ]\n\n      const patterns = analyzeTemporalPatterns(cases)\n      expect(patterns).toEqual([])\n    })\n\n    it('should handle NaN case values', () => {\n      const cases: CaseRecord[] = [\n        { case_value: NaN, outcome: 'Settled' },\n        { case_value: Number.POSITIVE_INFINITY, outcome: 'Judgment' },\n        { case_value: Number.NEGATIVE_INFINITY, outcome: 'Dismissed' },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      expect(patterns[0].average_case_value).toBe(0)\n    })\n  })\n\n  describe('Edge Cases - Confidence Interval Calculations', () => {\n    it('should calculate confidence intervals for high-variance datasets', () => {\n      const cases: CaseRecord[] = [\n        ...Array(50)\n          .fill(null)\n          .map(() => ({ case_type: 'Civil', outcome: 'Settled', case_value: 10000 })),\n        ...Array(50)\n          .fill(null)\n          .map(() => ({ case_type: 'Civil', outcome: 'Dismissed', case_value: 1000000 })),\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      const analysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, patterns, analysis)\n\n      expect(indicators.consistency_score).toBeLessThan(100)\n      expect(indicators.consistency_score).toBeGreaterThanOrEqual(0)\n    })\n\n    it('should handle perfect consistency (all same outcome)', () => {\n      const cases: CaseRecord[] = Array(100)\n        .fill(null)\n        .map(() => ({ case_type: 'Civil', outcome: 'Settled' }))\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      const analysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, patterns, analysis)\n\n      expect(indicators.consistency_score).toBe(100)\n      expect(analysis.overall_settlement_rate).toBe(1)\n    })\n\n    it('should handle zero variance in case durations', () => {\n      const cases: CaseRecord[] = Array(10)\n        .fill(null)\n        .map(() => ({\n          filing_date: '2023-01-01',\n          decision_date: '2023-02-01',\n          outcome: 'Settled',\n        }))\n\n      const analysis = analyzeOutcomes(cases)\n      expect(analysis.average_case_duration).toBeCloseTo(31, 0)\n    })\n  })\n\n  describe('Edge Cases - Statistical Significance', () => {\n    it('should detect statistically insignificant patterns with small samples', () => {\n      const cases: CaseRecord[] = [\n        { case_type: 'Civil', outcome: 'Settled' },\n        { case_type: 'Civil', outcome: 'Dismissed' },\n        { case_type: 'Criminal', outcome: 'Judgment' },\n      ]\n\n      const caseTypePatterns = analyzeCaseTypePatterns(cases)\n      const outcomeAnalysis = analyzeOutcomes(cases)\n      const indicators = calculateBiasIndicators(cases, caseTypePatterns, outcomeAnalysis)\n\n      expect(indicators.predictability_score).toBeLessThan(50)\n    })\n\n    it('should handle extreme settlement rates (100%)', () => {\n      const cases: CaseRecord[] = Array(500)\n        .fill(null)\n        .map(() => ({ outcome: 'Settled', case_type: 'Civil' }))\n\n      const analysis = analyzeOutcomes(cases)\n      const patterns = analyzeCaseTypePatterns(cases)\n      const indicators = calculateBiasIndicators(cases, patterns, analysis)\n\n      expect(analysis.overall_settlement_rate).toBe(1.0)\n      expect(indicators.settlement_preference).toBe(50.0)\n    })\n\n    it('should handle extreme settlement rates (0%)', () => {\n      const cases: CaseRecord[] = Array(500)\n        .fill(null)\n        .map(() => ({ outcome: 'Judgment', case_type: 'Civil' }))\n\n      const analysis = analyzeOutcomes(cases)\n      const patterns = analyzeCaseTypePatterns(cases)\n      const indicators = calculateBiasIndicators(cases, patterns, analysis)\n\n      expect(analysis.overall_settlement_rate).toBe(0)\n      expect(indicators.settlement_preference).toBe(-50.0)\n    })\n  })\n\n  describe('Edge Cases - Mixed Data Quality', () => {\n    it('should handle dataset with partially missing data', () => {\n      const cases: CaseRecord[] = [\n        {\n          case_type: 'Civil',\n          outcome: 'Settled',\n          case_value: 100000,\n          filing_date: '2023-01-01',\n          decision_date: '2023-03-01',\n        },\n        {\n          case_type: null,\n          outcome: 'Dismissed',\n          case_value: null,\n          filing_date: null,\n          decision_date: null,\n        },\n        {\n          case_type: 'Criminal',\n          outcome: null,\n          case_value: 50000,\n          filing_date: '2023-02-01',\n          decision_date: '2023-04-01',\n        },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      const analysis = analyzeOutcomes(cases)\n\n      expect(patterns).toHaveLength(3)\n      expect(analysis.overall_settlement_rate).toBeGreaterThanOrEqual(0)\n      expect(analysis.overall_settlement_rate).toBeLessThanOrEqual(1)\n    })\n\n    it('should handle empty strings as null values', () => {\n      const cases: CaseRecord[] = [\n        { case_type: '', outcome: '', case_value: 0 },\n        { case_type: 'Civil', outcome: 'Settled', case_value: 100000 },\n      ]\n\n      const patterns = analyzeCaseTypePatterns(cases)\n      expect(patterns.length).toBeGreaterThan(0)\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\auth\\is-admin.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (144). Maximum allowed is 60.",
        "line": 19,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 162,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Unit tests for admin authorization logic\r\n */\r\n\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\r\nimport { isAdmin, resolveAdminStatus, requireAdmin } from '@/lib/auth/is-admin'\r\nimport type { AppUserRecord } from '@/lib/auth/user-mapping'\r\n\r\n// Mock dependencies\r\nvi.mock('@/lib/auth/safe-auth', () => ({\r\n  safeAuth: vi.fn(async () => ({ userId: 'test-user-id' })),\r\n}))\r\n\r\nvi.mock('@/lib/auth/user-mapping', () => ({\r\n  ensureCurrentAppUser: vi.fn(),\r\n  fetchCurrentAppUser: vi.fn(),\r\n}))\r\n\r\ndescribe('Admin Authorization', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks()\r\n  })\r\n\r\n  describe('resolveAdminStatus', () => {\r\n    it('should return admin status for admin user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      const mockAdminUser: AppUserRecord = {\r\n        clerk_user_id: 'clerk_123',\r\n        email: 'admin@judgefinder.io',\r\n        full_name: 'Admin User',\r\n        is_admin: true,\r\n        last_seen_at: '2024-01-01T00:00:00Z',\r\n        created_at: '2024-01-01T00:00:00Z',\r\n        updated_at: '2024-01-01T00:00:00Z',\r\n      }\r\n\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue(mockAdminUser)\r\n\r\n      const result = await resolveAdminStatus()\r\n\r\n      expect(result.isAdmin).toBe(true)\r\n      expect(result.user).toEqual(mockAdminUser)\r\n      expect(ensureCurrentAppUser).toHaveBeenCalledTimes(1)\r\n    })\r\n\r\n    it('should return non-admin status for regular user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      const mockRegularUser: AppUserRecord = {\r\n        clerk_user_id: 'clerk_456',\r\n        email: 'user@example.com',\r\n        full_name: 'Regular User',\r\n        is_admin: false,\r\n        last_seen_at: '2024-01-01T00:00:00Z',\r\n        created_at: '2024-01-01T00:00:00Z',\r\n        updated_at: '2024-01-01T00:00:00Z',\r\n      }\r\n\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue(mockRegularUser)\r\n\r\n      const result = await resolveAdminStatus()\r\n\r\n      expect(result.isAdmin).toBe(false)\r\n      expect(result.user).toEqual(mockRegularUser)\r\n    })\r\n\r\n    it('should return false for null user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue(null)\r\n\r\n      const result = await resolveAdminStatus()\r\n\r\n      expect(result.isAdmin).toBe(false)\r\n      expect(result.user).toBeNull()\r\n    })\r\n  })\r\n\r\n  describe('isAdmin', () => {\r\n    it('should return true for admin user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue({\r\n        clerk_user_id: 'clerk_123',\r\n        email: 'admin@judgefinder.io',\r\n        full_name: 'Admin User',\r\n        is_admin: true,\r\n        last_seen_at: '2024-01-01T00:00:00Z',\r\n        created_at: '2024-01-01T00:00:00Z',\r\n        updated_at: '2024-01-01T00:00:00Z',\r\n      })\r\n\r\n      const result = await isAdmin()\r\n\r\n      expect(result).toBe(true)\r\n    })\r\n\r\n    it('should return false for non-admin user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue({\r\n        clerk_user_id: 'clerk_456',\r\n        email: 'user@example.com',\r\n        full_name: 'Regular User',\r\n        is_admin: false,\r\n        last_seen_at: '2024-01-01T00:00:00Z',\r\n        created_at: '2024-01-01T00:00:00Z',\r\n        updated_at: '2024-01-01T00:00:00Z',\r\n      })\r\n\r\n      const result = await isAdmin()\r\n\r\n      expect(result).toBe(false)\r\n    })\r\n\r\n    it('should return false on error', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      vi.mocked(ensureCurrentAppUser).mockRejectedValue(new Error('Database error'))\r\n\r\n      const result = await isAdmin()\r\n\r\n      expect(result).toBe(false)\r\n    })\r\n  })\r\n\r\n  describe('requireAdmin', () => {\r\n    it('should not throw for admin user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue({\r\n        clerk_user_id: 'clerk_123',\r\n        email: 'admin@judgefinder.io',\r\n        full_name: 'Admin User',\r\n        is_admin: true,\r\n        last_seen_at: '2024-01-01T00:00:00Z',\r\n        created_at: '2024-01-01T00:00:00Z',\r\n        updated_at: '2024-01-01T00:00:00Z',\r\n      })\r\n\r\n      await expect(requireAdmin()).resolves.not.toThrow()\r\n    })\r\n\r\n    it('should throw for non-admin user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue({\r\n        clerk_user_id: 'clerk_456',\r\n        email: 'user@example.com',\r\n        full_name: 'Regular User',\r\n        is_admin: false,\r\n        last_seen_at: '2024-01-01T00:00:00Z',\r\n        created_at: '2024-01-01T00:00:00Z',\r\n        updated_at: '2024-01-01T00:00:00Z',\r\n      })\r\n\r\n      await expect(requireAdmin()).rejects.toThrow('Admin access required')\r\n    })\r\n\r\n    it('should throw for unauthenticated user', async () => {\r\n      const { ensureCurrentAppUser } = await import('@/lib/auth/user-mapping')\r\n      vi.mocked(ensureCurrentAppUser).mockResolvedValue(null)\r\n\r\n      await expect(requireAdmin()).rejects.toThrow('Authentication required')\r\n    })\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\courts\\assignment-validation.test.ts",
    "messages": [],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 0,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\domain\\aggregates\\JudgeAggregate.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (399). Maximum allowed is 60.",
        "line": 4,
        "column": 28,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 404,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (103). Maximum allowed is 60.",
        "line": 62,
        "column": 29,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 166,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (69). Maximum allowed is 60.",
        "line": 168,
        "column": 34,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 236,
        "endColumn": 4
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (66). Maximum allowed is 60.",
        "line": 264,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 329,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 4,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect } from 'vitest'\nimport { JudgeAggregate } from '@/lib/domain/aggregates/JudgeAggregate'\n\ndescribe('JudgeAggregate', () => {\n  describe('create', () => {\n    it('should create a valid judge aggregate', () => {\n      const result = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      })\n\n      expect(result.isOk()).toBe(true)\n      const judge = result.unwrap()\n      expect(judge.id).toBe('judge-1')\n      expect(judge.name).toBe('Judge Smith')\n      expect(judge.totalCases).toBe(100)\n    })\n\n    it('should reject empty ID', () => {\n      const result = JudgeAggregate.create({\n        id: '',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('ID is required')\n    })\n\n    it('should reject empty name', () => {\n      const result = JudgeAggregate.create({\n        id: 'judge-1',\n        name: '',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('name is required')\n    })\n\n    it('should reject negative case count', () => {\n      const result = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: -10,\n        positions: [],\n        jurisdiction: 'California',\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot be negative')\n    })\n  })\n\n  describe('assignToCourt', () => {\n    it('should assign judge to court successfully', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.assignToCourt(\n        'court-1',\n        'Superior Court of California',\n        'primary',\n        new Date('2020-01-01')\n      )\n\n      expect(result.isOk()).toBe(true)\n      expect(judge.getActivePositions().length).toBe(1)\n      expect(judge.getPrimaryCourt()?.courtId).toBe('court-1')\n    })\n\n    it('should reject multiple active primary positions', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      // First assignment succeeds\n      judge.assignToCourt('court-1', 'Superior Court 1', 'primary', new Date('2020-01-01'))\n\n      // Second primary assignment should fail\n      const result = judge.assignToCourt(\n        'court-2',\n        'Superior Court 2',\n        'primary',\n        new Date('2020-06-01')\n      )\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('already has an active primary position')\n    })\n\n    it('should allow visiting position alongside primary', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.assignToCourt('court-1', 'Superior Court 1', 'primary', new Date('2020-01-01'))\n      const result = judge.assignToCourt(\n        'court-2',\n        'Superior Court 2',\n        'visiting',\n        new Date('2020-06-01')\n      )\n\n      expect(result.isOk()).toBe(true)\n      expect(judge.getActivePositions().length).toBe(2)\n    })\n\n    it('should detect temporal overlap in same court', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.assignToCourt('court-1', 'Superior Court', 'primary', new Date('2020-01-01'))\n\n      const result = judge.assignToCourt(\n        'court-1',\n        'Superior Court',\n        'visiting',\n        new Date('2020-06-01')\n      )\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('overlapping position')\n    })\n\n    it('should publish domain event on assignment', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.assignToCourt('court-1', 'Superior Court', 'primary', new Date('2020-01-01'))\n\n      const events = judge.collectDomainEvents()\n      expect(events.length).toBe(1)\n      expect(events[0].eventType).toBe('JudgeAssignedToCourt')\n    })\n  })\n\n  describe('retireFromPosition', () => {\n    it('should retire judge from position', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.assignToCourt('court-1', 'Superior Court', 'primary', new Date('2000-01-01'))\n\n      const result = judge.retireFromPosition('court-1', new Date('2020-01-01'), 'full')\n\n      expect(result.isOk()).toBe(true)\n      expect(judge.isActive()).toBe(false)\n    })\n\n    it('should reject retirement date before start date', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.assignToCourt('court-1', 'Superior Court', 'primary', new Date('2020-01-01'))\n\n      const result = judge.retireFromPosition('court-1', new Date('2019-01-01'), 'full')\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot be before')\n    })\n\n    it('should reject retirement from non-existent position', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.retireFromPosition('court-1', new Date('2020-01-01'), 'full')\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('No active position')\n    })\n\n    it('should publish retirement event', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.assignToCourt('court-1', 'Superior Court', 'primary', new Date('2000-01-01'))\n      judge.collectDomainEvents() // Clear assignment event\n\n      judge.retireFromPosition('court-1', new Date('2020-01-01'), 'full')\n\n      const events = judge.collectDomainEvents()\n      expect(events.length).toBe(1)\n      expect(events[0].eventType).toBe('JudgeRetired')\n    })\n  })\n\n  describe('canCalculateBiasMetrics', () => {\n    it('should return true for judge with 500+ cases', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 600,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      expect(judge.canCalculateBiasMetrics()).toBe(true)\n    })\n\n    it('should return false for judge with less than 500 cases', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 400,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      expect(judge.canCalculateBiasMetrics()).toBe(false)\n    })\n  })\n\n  describe('calculateBiasMetrics', () => {\n    it('should calculate metrics for eligible judge', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 600,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.calculateBiasMetrics({\n        consistencyScore: 85,\n        speedScore: 75,\n        settlementPreference: 10,\n        riskTolerance: 60,\n        predictabilityScore: 80,\n      })\n\n      expect(result.isOk()).toBe(true)\n      expect(judge.biasMetrics).toBeDefined()\n      expect(judge.biasMetrics?.consistencyScore).toBe(85)\n    })\n\n    it('should reject calculation for ineligible judge', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 400,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.calculateBiasMetrics({\n        consistencyScore: 85,\n        speedScore: 75,\n        settlementPreference: 10,\n        riskTolerance: 60,\n        predictabilityScore: 80,\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('Minimum 500 cases')\n    })\n\n    it('should publish eligibility event on first calculation', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 600,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      judge.calculateBiasMetrics({\n        consistencyScore: 85,\n        speedScore: 75,\n        settlementPreference: 10,\n        riskTolerance: 60,\n        predictabilityScore: 80,\n      })\n\n      const events = judge.collectDomainEvents()\n      expect(events.some((e) => e.eventType === 'JudgeEligibleForBiasAnalysis')).toBe(true)\n      expect(events.some((e) => e.eventType === 'BiasMetricsCalculated')).toBe(true)\n    })\n  })\n\n  describe('updateCaseCount', () => {\n    it('should update case count', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.updateCaseCount(150)\n      expect(result.isOk()).toBe(true)\n      expect(judge.totalCases).toBe(150)\n    })\n\n    it('should reject negative case count', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.updateCaseCount(-10)\n      expect(result.isErr()).toBe(true)\n    })\n\n    it('should reject decreasing case count', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const result = judge.updateCaseCount(50)\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot decrease')\n    })\n  })\n\n  describe('JSON serialization', () => {\n    it('should serialize to JSON', () => {\n      const judge = JudgeAggregate.create({\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }).unwrap()\n\n      const json = judge.toJSON()\n      expect(json.id).toBe('judge-1')\n      expect(json.name).toBe('Judge Smith')\n      expect(json.totalCases).toBe(100)\n    })\n\n    it('should deserialize from JSON', () => {\n      const json = {\n        id: 'judge-1',\n        name: 'Judge Smith',\n        totalCases: 100,\n        positions: [],\n        jurisdiction: 'California',\n      }\n\n      const result = JudgeAggregate.fromJSON(json)\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().id).toBe('judge-1')\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\domain\\services\\AdPricingService.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (390). Maximum allowed is 60.",
        "line": 4,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 412,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (215). Maximum allowed is 60.",
        "line": 7,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 227,
        "endColumn": 4
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 2,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect } from 'vitest'\nimport { AdPricingService } from '@/lib/domain/services/AdPricingService'\n\ndescribe('AdPricingService', () => {\n  const service = new AdPricingService()\n\n  describe('calculatePricing', () => {\n    it('should calculate basic state court pricing', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.basePrice.dollars).toBe(299)\n      expect(breakdown.finalPrice.dollars).toBe(299)\n    })\n\n    it('should apply federal court multiplier (2x)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'federal',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.courtLevelMultiplier).toBe(2.0)\n      expect(breakdown.finalPrice.dollars).toBe(598) // 299 * 2\n    })\n\n    it('should apply premium judge multiplier (1.3x)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: true,\n        bundleSize: 1,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.premiumMultiplier).toBe(1.3)\n      expect(breakdown.finalPrice.dollars).toBeCloseTo(388.7, 1) // 299 * 1.3\n    })\n\n    it('should apply exclusive placement multiplier (1.5x)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: true,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.exclusiveMultiplier).toBe(1.5)\n      expect(breakdown.finalPrice.dollars).toBeCloseTo(448.5, 1) // 299 * 1.5\n    })\n\n    it('should apply volume discount for 3+ spots (10%)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 3,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.volumeDiscount).toBe(0.1)\n      // 299 * 3 = 897, minus 10% = 807.30\n      expect(breakdown.finalPrice.dollars).toBeCloseTo(807.3, 1)\n    })\n\n    it('should apply volume discount for 5+ spots (15%)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 5,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.volumeDiscount).toBe(0.15)\n      // 299 * 5 = 1495, minus 15% = 1270.75\n      expect(breakdown.finalPrice.dollars).toBeCloseTo(1270.75, 1)\n    })\n\n    it('should apply volume discount for 10+ spots (20%)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 10,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.volumeDiscount).toBe(0.2)\n      // 299 * 10 = 2990, minus 20% = 2392\n      expect(breakdown.finalPrice.dollars).toBe(2392)\n    })\n\n    it('should apply annual discount (2 months free)', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 12,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      expect(breakdown.annualDiscount).toBeCloseTo(0.1667, 4)\n      // 299 * 12 = 3588, minus ~16.67% = ~2990\n      expect(breakdown.finalPrice.dollars).toBeCloseTo(2990, 0)\n    })\n\n    it('should combine volume and annual discounts', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 5,\n        durationMonths: 12,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      // Volume: 15%, Annual: 16.67% = 31.67% total\n      expect(breakdown.volumeDiscount + breakdown.annualDiscount).toBeCloseTo(0.3167, 3)\n    })\n\n    it('should calculate correct price per month for annual', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 12,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n      // Total ~2990, divided by 12 = ~249.17\n      expect(breakdown.pricePerMonth.dollars).toBeCloseTo(249.17, 1)\n    })\n\n    it('should validate bundle size minimum', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 0,\n        durationMonths: 1,\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('at least 1')\n    })\n\n    it('should validate bundle size maximum', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 51,\n        durationMonths: 1,\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot exceed 50')\n    })\n\n    it('should validate duration minimum', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 0,\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('at least 1 month')\n    })\n\n    it('should validate duration maximum', () => {\n      const result = service.calculatePricing({\n        tier: 'basic',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 37,\n      })\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot exceed 36')\n    })\n  })\n\n  describe('calculateMonthlyPrice', () => {\n    it('should return monthly price without full breakdown', () => {\n      const result = service.calculateMonthlyPrice({\n        tier: 'standard',\n        courtLevel: 'state',\n        isExclusive: false,\n        isPremiumJudge: false,\n        bundleSize: 1,\n        durationMonths: 1,\n      })\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(499)\n    })\n  })\n\n  describe('estimateAnnualSavings', () => {\n    it('should calculate annual savings correctly', () => {\n      const result = service.estimateAnnualSavings('basic', 'state')\n\n      expect(result.isOk()).toBe(true)\n      const savings = result.unwrap()\n      // Monthly: 299 * 12 = 3588\n      // Annual: ~2990\n      // Savings: ~598 (2 months)\n      expect(savings.dollars).toBeCloseTo(598, 0)\n    })\n\n    it('should show higher savings for premium tiers', () => {\n      const basicResult = service.estimateAnnualSavings('basic', 'state')\n      const premiumResult = service.estimateAnnualSavings('premium', 'state')\n\n      expect(basicResult.isOk()).toBe(true)\n      expect(premiumResult.isOk()).toBe(true)\n\n      const basicSavings = basicResult.unwrap()\n      const premiumSavings = premiumResult.unwrap()\n\n      expect(premiumSavings.greaterThan(basicSavings)).toBe(true)\n    })\n  })\n\n  describe('compareTiers', () => {\n    it('should compare all tiers for state court', () => {\n      const result = service.compareTiers('state', 1)\n\n      expect(result.isOk()).toBe(true)\n      const comparison = result.unwrap()\n\n      expect(comparison.basic.finalPrice.dollars).toBe(299)\n      expect(comparison.standard.finalPrice.dollars).toBe(499)\n      expect(comparison.premium.finalPrice.dollars).toBe(799)\n      expect(comparison.enterprise.finalPrice.dollars).toBe(1499)\n    })\n\n    it('should compare all tiers for federal court', () => {\n      const result = service.compareTiers('federal', 1)\n\n      expect(result.isOk()).toBe(true)\n      const comparison = result.unwrap()\n\n      // All prices should be 2x state prices\n      expect(comparison.basic.finalPrice.dollars).toBe(598)\n      expect(comparison.standard.finalPrice.dollars).toBe(998)\n      expect(comparison.premium.finalPrice.dollars).toBe(1598)\n      expect(comparison.enterprise.finalPrice.dollars).toBe(2998)\n    })\n  })\n\n  describe('calculateROIThreshold', () => {\n    it('should calculate break-even clients', () => {\n      const pricing = service\n        .calculatePricing({\n          tier: 'basic',\n          courtLevel: 'state',\n          isExclusive: false,\n          isPremiumJudge: false,\n          bundleSize: 1,\n          durationMonths: 1,\n        })\n        .unwrap()\n\n      const result = service.calculateROIThreshold(pricing, 1500)\n\n      expect(result.isOk()).toBe(true)\n      // 299 / 1500 = 0.199, rounded up = 1 client\n      expect(result.unwrap()).toBe(1)\n    })\n\n    it('should round up for partial clients', () => {\n      const pricing = service\n        .calculatePricing({\n          tier: 'premium',\n          courtLevel: 'state',\n          isExclusive: false,\n          isPremiumJudge: false,\n          bundleSize: 1,\n          durationMonths: 1,\n        })\n        .unwrap()\n\n      const result = service.calculateROIThreshold(pricing, 300)\n\n      expect(result.isOk()).toBe(true)\n      // 799 / 300 = 2.66, rounded up = 3 clients\n      expect(result.unwrap()).toBe(3)\n    })\n\n    it('should reject non-positive client value', () => {\n      const pricing = service\n        .calculatePricing({\n          tier: 'basic',\n          courtLevel: 'state',\n          isExclusive: false,\n          isPremiumJudge: false,\n          bundleSize: 1,\n          durationMonths: 1,\n        })\n        .unwrap()\n\n      const result = service.calculateROIThreshold(pricing, 0)\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('must be positive')\n    })\n  })\n\n  describe('recommendTier', () => {\n    it('should recommend basic for low budget', () => {\n      const tier = service.recommendTier(300, 'state')\n      expect(tier).toBe('basic')\n    })\n\n    it('should recommend standard for medium budget', () => {\n      const tier = service.recommendTier(500, 'state')\n      expect(tier).toBe('standard')\n    })\n\n    it('should recommend premium for high budget', () => {\n      const tier = service.recommendTier(800, 'state')\n      expect(tier).toBe('premium')\n    })\n\n    it('should recommend enterprise for very high budget', () => {\n      const tier = service.recommendTier(1500, 'state')\n      expect(tier).toBe('enterprise')\n    })\n\n    it('should account for federal multiplier', () => {\n      // 600 for federal should recommend basic (600 / 2 = 300)\n      const tier = service.recommendTier(600, 'federal')\n      expect(tier).toBe('basic')\n    })\n  })\n\n  describe('complex pricing scenarios', () => {\n    it('should handle premium federal exclusive annual bundle correctly', () => {\n      const result = service.calculatePricing({\n        tier: 'premium',\n        courtLevel: 'federal',\n        isExclusive: true,\n        isPremiumJudge: true,\n        bundleSize: 5,\n        durationMonths: 12,\n      })\n\n      expect(result.isOk()).toBe(true)\n      const breakdown = result.unwrap()\n\n      // Base: 799\n      // Multipliers: 2 (federal) * 1.5 (exclusive) * 1.3 (premium) = 3.9\n      // Bundle: 5 spots\n      // Duration: 12 months\n      // Subtotal: 799 * 3.9 * 5 * 12 = 187,362\n      // Discounts: 15% (volume) + 16.67% (annual) = 31.67%, capped at 35%\n\n      expect(breakdown.courtLevelMultiplier).toBe(2.0)\n      expect(breakdown.exclusiveMultiplier).toBe(1.5)\n      expect(breakdown.premiumMultiplier).toBe(1.3)\n      expect(breakdown.finalPrice.isPositive()).toBe(true)\n      expect(breakdown.savings.isPositive()).toBe(true)\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\domain\\value-objects\\BarNumber.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (156). Maximum allowed is 60.",
        "line": 4,
        "column": 36,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 159,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect } from 'vitest'\nimport { BarNumber } from '@/lib/domain/value-objects/BarNumber'\n\ndescribe('BarNumber Value Object', () => {\n  describe('create', () => {\n    it('should create a valid bar number', () => {\n      const result = BarNumber.create('CA', '123456')\n      expect(result.isOk()).toBe(true)\n\n      const barNumber = result.unwrap()\n      expect(barNumber.state).toBe('CA')\n      expect(barNumber.number).toBe('123456')\n    })\n\n    it('should normalize state code to uppercase', () => {\n      const result = BarNumber.create('ca', '123456')\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().state).toBe('CA')\n    })\n\n    it('should reject invalid state code', () => {\n      const result = BarNumber.create('XX', '123456')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('Invalid state code')\n    })\n\n    it('should reject empty bar number', () => {\n      const result = BarNumber.create('CA', '')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot be empty')\n    })\n\n    it('should reject bar number with invalid characters', () => {\n      const result = BarNumber.create('CA', '123@456')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('only letters, numbers')\n    })\n\n    it('should reject bar number that is too short', () => {\n      const result = BarNumber.create('CA', '123')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('between 4 and 12')\n    })\n\n    it('should reject bar number that is too long', () => {\n      const result = BarNumber.create('CA', '1234567890123')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('between 4 and 12')\n    })\n\n    it('should accept bar numbers with hyphens and spaces', () => {\n      const result1 = BarNumber.create('CA', '123-456')\n      const result2 = BarNumber.create('NY', '123 456')\n\n      expect(result1.isOk()).toBe(true)\n      expect(result2.isOk()).toBe(true)\n    })\n  })\n\n  describe('parse', () => {\n    it('should parse hyphen-separated format', () => {\n      const result = BarNumber.parse('CA-123456')\n      expect(result.isOk()).toBe(true)\n\n      const barNumber = result.unwrap()\n      expect(barNumber.state).toBe('CA')\n      expect(barNumber.number).toBe('123456')\n    })\n\n    it('should parse space-separated format', () => {\n      const result = BarNumber.parse('NY 987654')\n      expect(result.isOk()).toBe(true)\n\n      const barNumber = result.unwrap()\n      expect(barNumber.state).toBe('NY')\n      expect(barNumber.number).toBe('987654')\n    })\n\n    it('should reject invalid format', () => {\n      const result = BarNumber.parse('123456')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('format')\n    })\n\n    it('should handle whitespace', () => {\n      const result = BarNumber.parse('  CA-123456  ')\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().toString()).toBe('CA-123456')\n    })\n  })\n\n  describe('toString', () => {\n    it('should format as STATE-NUMBER', () => {\n      const barNumber = BarNumber.create('CA', '123456').unwrap()\n      expect(barNumber.toString()).toBe('CA-123456')\n    })\n  })\n\n  describe('equals', () => {\n    it('should return true for identical bar numbers', () => {\n      const bn1 = BarNumber.create('CA', '123456').unwrap()\n      const bn2 = BarNumber.create('CA', '123456').unwrap()\n      expect(bn1.equals(bn2)).toBe(true)\n    })\n\n    it('should return false for different bar numbers', () => {\n      const bn1 = BarNumber.create('CA', '123456').unwrap()\n      const bn2 = BarNumber.create('CA', '654321').unwrap()\n      expect(bn1.equals(bn2)).toBe(false)\n    })\n\n    it('should return false for different states', () => {\n      const bn1 = BarNumber.create('CA', '123456').unwrap()\n      const bn2 = BarNumber.create('NY', '123456').unwrap()\n      expect(bn1.equals(bn2)).toBe(false)\n    })\n  })\n\n  describe('normalize', () => {\n    it('should remove spaces and hyphens', () => {\n      const barNumber = BarNumber.create('CA', '123-456').unwrap()\n      const normalized = barNumber.normalize()\n      expect(normalized.number).toBe('123456')\n    })\n\n    it('should remove multiple spaces', () => {\n      const barNumber = BarNumber.create('NY', '123  456').unwrap()\n      const normalized = barNumber.normalize()\n      expect(normalized.number).toBe('123456')\n    })\n  })\n\n  describe('JSON serialization', () => {\n    it('should serialize to JSON', () => {\n      const barNumber = BarNumber.create('CA', '123456').unwrap()\n      const json = barNumber.toJSON()\n\n      expect(json.state).toBe('CA')\n      expect(json.number).toBe('123456')\n      expect(json.full).toBe('CA-123456')\n    })\n\n    it('should deserialize from JSON', () => {\n      const json = { state: 'CA', number: '123456' }\n      const result = BarNumber.fromJSON(json)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().toString()).toBe('CA-123456')\n    })\n  })\n\n  describe('DC (District of Columbia)', () => {\n    it('should accept DC as a valid state code', () => {\n      const result = BarNumber.create('DC', '123456')\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().state).toBe('DC')\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\domain\\value-objects\\Jurisdiction.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (220). Maximum allowed is 60.",
        "line": 4,
        "column": 39,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 223,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect } from 'vitest'\nimport { Jurisdiction } from '@/lib/domain/value-objects/Jurisdiction'\n\ndescribe('Jurisdiction Value Object', () => {\n  describe('federal', () => {\n    it('should create a federal jurisdiction without district', () => {\n      const result = Jurisdiction.federal()\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.level).toBe('federal')\n      expect(jurisdiction.isFederal()).toBe(true)\n      expect(jurisdiction.toString()).toBe('Federal')\n    })\n\n    it('should create a federal jurisdiction with district', () => {\n      const result = Jurisdiction.federal('Northern District of California')\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.district).toBe('Northern District of California')\n      expect(jurisdiction.toString()).toBe('Federal - Northern District of California')\n    })\n  })\n\n  describe('state', () => {\n    it('should create a state jurisdiction', () => {\n      const result = Jurisdiction.state('California')\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.level).toBe('state')\n      expect(jurisdiction.state).toBe('California')\n      expect(jurisdiction.isState()).toBe(true)\n      expect(jurisdiction.toString()).toBe('California')\n    })\n\n    it('should reject empty state', () => {\n      const result = Jurisdiction.state('')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot be empty')\n    })\n\n    it('should trim whitespace', () => {\n      const result = Jurisdiction.state('  California  ')\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().state).toBe('California')\n    })\n  })\n\n  describe('county', () => {\n    it('should create a county jurisdiction', () => {\n      const result = Jurisdiction.county('California', 'Los Angeles')\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.level).toBe('county')\n      expect(jurisdiction.state).toBe('California')\n      expect(jurisdiction.county).toBe('Los Angeles')\n      expect(jurisdiction.isCounty()).toBe(true)\n      expect(jurisdiction.toString()).toBe('Los Angeles County, California')\n    })\n\n    it('should reject empty state', () => {\n      const result = Jurisdiction.county('', 'Los Angeles')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('State cannot be empty')\n    })\n\n    it('should reject empty county', () => {\n      const result = Jurisdiction.county('California', '')\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('County cannot be empty')\n    })\n  })\n\n  describe('parse', () => {\n    it('should parse \"Federal\"', () => {\n      const result = Jurisdiction.parse('Federal')\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().isFederal()).toBe(true)\n    })\n\n    it('should parse federal with district', () => {\n      const result = Jurisdiction.parse('Federal - Northern District of California')\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.isFederal()).toBe(true)\n      expect(jurisdiction.district).toBe('Northern District of California')\n    })\n\n    it('should parse county format', () => {\n      const result = Jurisdiction.parse('Los Angeles County, California')\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.isCounty()).toBe(true)\n      expect(jurisdiction.county).toBe('Los Angeles')\n      expect(jurisdiction.state).toBe('California')\n    })\n\n    it('should parse state as default', () => {\n      const result = Jurisdiction.parse('California')\n      expect(result.isOk()).toBe(true)\n\n      const jurisdiction = result.unwrap()\n      expect(jurisdiction.isState()).toBe(true)\n      expect(jurisdiction.state).toBe('California')\n    })\n  })\n\n  describe('isWithin', () => {\n    it('should return true for county within state', () => {\n      const county = Jurisdiction.county('California', 'Los Angeles').unwrap()\n      const state = Jurisdiction.state('California').unwrap()\n\n      expect(county.isWithin(state)).toBe(true)\n    })\n\n    it('should return false for county not in state', () => {\n      const county = Jurisdiction.county('California', 'Los Angeles').unwrap()\n      const state = Jurisdiction.state('New York').unwrap()\n\n      expect(county.isWithin(state)).toBe(false)\n    })\n\n    it('should return true for any jurisdiction within federal', () => {\n      const state = Jurisdiction.state('California').unwrap()\n      const county = Jurisdiction.county('California', 'Los Angeles').unwrap()\n      const federal = Jurisdiction.federal().unwrap()\n\n      expect(state.isWithin(federal)).toBe(true)\n      expect(county.isWithin(federal)).toBe(true)\n    })\n\n    it('should return true for identical jurisdictions', () => {\n      const j1 = Jurisdiction.state('California').unwrap()\n      const j2 = Jurisdiction.state('California').unwrap()\n\n      expect(j1.isWithin(j2)).toBe(true)\n    })\n  })\n\n  describe('toShortString', () => {\n    it('should return short string for federal', () => {\n      const jurisdiction = Jurisdiction.federal('Northern District of California').unwrap()\n      expect(jurisdiction.toShortString()).toBe('Federal')\n    })\n\n    it('should return short string for county', () => {\n      const jurisdiction = Jurisdiction.county('California', 'Los Angeles').unwrap()\n      expect(jurisdiction.toShortString()).toBe('Los Angeles County')\n    })\n\n    it('should return state name for state', () => {\n      const jurisdiction = Jurisdiction.state('California').unwrap()\n      expect(jurisdiction.toShortString()).toBe('California')\n    })\n  })\n\n  describe('equals', () => {\n    it('should return true for identical jurisdictions', () => {\n      const j1 = Jurisdiction.state('California').unwrap()\n      const j2 = Jurisdiction.state('California').unwrap()\n      expect(j1.equals(j2)).toBe(true)\n    })\n\n    it('should return false for different jurisdictions', () => {\n      const j1 = Jurisdiction.state('California').unwrap()\n      const j2 = Jurisdiction.state('New York').unwrap()\n      expect(j1.equals(j2)).toBe(false)\n    })\n\n    it('should return false for different levels', () => {\n      const state = Jurisdiction.state('California').unwrap()\n      const federal = Jurisdiction.federal().unwrap()\n      expect(state.equals(federal)).toBe(false)\n    })\n  })\n\n  describe('JSON serialization', () => {\n    it('should serialize federal jurisdiction', () => {\n      const jurisdiction = Jurisdiction.federal('Northern District').unwrap()\n      const json = jurisdiction.toJSON()\n\n      expect(json.level).toBe('federal')\n      expect(json.district).toBe('Northern District')\n      expect(json.display).toBe('Federal - Northern District')\n    })\n\n    it('should serialize state jurisdiction', () => {\n      const jurisdiction = Jurisdiction.state('California').unwrap()\n      const json = jurisdiction.toJSON()\n\n      expect(json.level).toBe('state')\n      expect(json.state).toBe('California')\n      expect(json.display).toBe('California')\n    })\n\n    it('should serialize county jurisdiction', () => {\n      const jurisdiction = Jurisdiction.county('California', 'Los Angeles').unwrap()\n      const json = jurisdiction.toJSON()\n\n      expect(json.level).toBe('county')\n      expect(json.state).toBe('California')\n      expect(json.county).toBe('Los Angeles')\n      expect(json.display).toBe('Los Angeles County, California')\n    })\n\n    it('should deserialize from JSON', () => {\n      const json = {\n        level: 'county' as const,\n        state: 'California',\n        county: 'Los Angeles',\n      }\n      const result = Jurisdiction.fromJSON(json)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().toString()).toBe('Los Angeles County, California')\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\domain\\value-objects\\Money.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (347). Maximum allowed is 60.",
        "line": 4,
        "column": 32,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 350,
        "endColumn": 2
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 1,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "import { describe, it, expect } from 'vitest'\nimport { Money } from '@/lib/domain/value-objects/Money'\n\ndescribe('Money Value Object', () => {\n  describe('fromDollars', () => {\n    it('should create money from dollar amount', () => {\n      const result = Money.fromDollars(100.5)\n      expect(result.isOk()).toBe(true)\n\n      const money = result.unwrap()\n      expect(money.dollars).toBe(100.5)\n      expect(money.cents).toBe(10050)\n    })\n\n    it('should handle whole dollar amounts', () => {\n      const result = Money.fromDollars(100)\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().cents).toBe(10000)\n    })\n\n    it('should reject negative amounts', () => {\n      const result = Money.fromDollars(-10)\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('cannot be negative')\n    })\n\n    it('should reject NaN', () => {\n      const result = Money.fromDollars(NaN)\n      expect(result.isErr()).toBe(true)\n    })\n\n    it('should reject infinity', () => {\n      const result = Money.fromDollars(Infinity)\n      expect(result.isErr()).toBe(true)\n    })\n\n    it('should handle floating-point precision correctly', () => {\n      const result = Money.fromDollars(0.1 + 0.2) // Classic JS problem\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().cents).toBe(30) // Should be 30 cents, not 30.000000000000004\n    })\n  })\n\n  describe('fromCents', () => {\n    it('should create money from cents', () => {\n      const result = Money.fromCents(10050)\n      expect(result.isOk()).toBe(true)\n\n      const money = result.unwrap()\n      expect(money.cents).toBe(10050)\n      expect(money.dollars).toBe(100.5)\n    })\n\n    it('should reject non-integer cents', () => {\n      const result = Money.fromCents(100.5)\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('must be an integer')\n    })\n\n    it('should reject negative cents', () => {\n      const result = Money.fromCents(-100)\n      expect(result.isErr()).toBe(true)\n    })\n  })\n\n  describe('zero', () => {\n    it('should create a zero money value', () => {\n      const money = Money.zero()\n      expect(money.cents).toBe(0)\n      expect(money.dollars).toBe(0)\n      expect(money.isZero()).toBe(true)\n    })\n  })\n\n  describe('add', () => {\n    it('should add two money values', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(5).unwrap()\n      const result = m1.add(m2)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(15)\n    })\n\n    it('should reject adding different currencies', () => {\n      const m1 = Money.fromDollars(10, 'USD').unwrap()\n      const m2 = Money.fromDollars(5, 'EUR').unwrap()\n      const result = m1.add(m2)\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('different currencies')\n    })\n  })\n\n  describe('subtract', () => {\n    it('should subtract two money values', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(5).unwrap()\n      const result = m1.subtract(m2)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(5)\n    })\n\n    it('should reject subtraction resulting in negative', () => {\n      const m1 = Money.fromDollars(5).unwrap()\n      const m2 = Money.fromDollars(10).unwrap()\n      const result = m1.subtract(m2)\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('negative amount')\n    })\n\n    it('should reject subtracting different currencies', () => {\n      const m1 = Money.fromDollars(10, 'USD').unwrap()\n      const m2 = Money.fromDollars(5, 'EUR').unwrap()\n      const result = m1.subtract(m2)\n\n      expect(result.isErr()).toBe(true)\n    })\n  })\n\n  describe('multiply', () => {\n    it('should multiply by a factor', () => {\n      const money = Money.fromDollars(10).unwrap()\n      const result = money.multiply(2.5)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(25)\n    })\n\n    it('should round correctly', () => {\n      const money = Money.fromDollars(10).unwrap()\n      const result = money.multiply(1.5)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(15)\n    })\n\n    it('should reject negative factor', () => {\n      const money = Money.fromDollars(10).unwrap()\n      const result = money.multiply(-2)\n\n      expect(result.isErr()).toBe(true)\n    })\n  })\n\n  describe('divide', () => {\n    it('should divide by a divisor', () => {\n      const money = Money.fromDollars(10).unwrap()\n      const result = money.divide(2)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(5)\n    })\n\n    it('should reject division by zero', () => {\n      const money = Money.fromDollars(10).unwrap()\n      const result = money.divide(0)\n\n      expect(result.isErr()).toBe(true)\n      expect(result.error().message).toContain('divide by zero')\n    })\n\n    it('should reject negative divisor', () => {\n      const money = Money.fromDollars(10).unwrap()\n      const result = money.divide(-2)\n\n      expect(result.isErr()).toBe(true)\n    })\n  })\n\n  describe('applyDiscount', () => {\n    it('should apply percentage discount', () => {\n      const money = Money.fromDollars(100).unwrap()\n      const result = money.applyDiscount(20) // 20% off\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(80)\n    })\n\n    it('should reject discount over 100%', () => {\n      const money = Money.fromDollars(100).unwrap()\n      const result = money.applyDiscount(150)\n\n      expect(result.isErr()).toBe(true)\n    })\n\n    it('should reject negative discount', () => {\n      const money = Money.fromDollars(100).unwrap()\n      const result = money.applyDiscount(-10)\n\n      expect(result.isErr()).toBe(true)\n    })\n  })\n\n  describe('percentage', () => {\n    it('should calculate percentage of amount', () => {\n      const money = Money.fromDollars(100).unwrap()\n      const result = money.percentage(15) // 15%\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(15)\n    })\n  })\n\n  describe('comparisons', () => {\n    it('should compare greater than', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(5).unwrap()\n      expect(m1.greaterThan(m2)).toBe(true)\n      expect(m2.greaterThan(m1)).toBe(false)\n    })\n\n    it('should compare less than', () => {\n      const m1 = Money.fromDollars(5).unwrap()\n      const m2 = Money.fromDollars(10).unwrap()\n      expect(m1.lessThan(m2)).toBe(true)\n      expect(m2.lessThan(m1)).toBe(false)\n    })\n\n    it('should compare greater than or equal', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(10).unwrap()\n      const m3 = Money.fromDollars(5).unwrap()\n\n      expect(m1.greaterThanOrEqual(m2)).toBe(true)\n      expect(m1.greaterThanOrEqual(m3)).toBe(true)\n    })\n\n    it('should compare less than or equal', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(10).unwrap()\n      const m3 = Money.fromDollars(15).unwrap()\n\n      expect(m1.lessThanOrEqual(m2)).toBe(true)\n      expect(m1.lessThanOrEqual(m3)).toBe(true)\n    })\n  })\n\n  describe('isZero', () => {\n    it('should return true for zero amount', () => {\n      const money = Money.zero()\n      expect(money.isZero()).toBe(true)\n    })\n\n    it('should return false for non-zero amount', () => {\n      const money = Money.fromDollars(10).unwrap()\n      expect(money.isZero()).toBe(false)\n    })\n  })\n\n  describe('isPositive', () => {\n    it('should return true for positive amount', () => {\n      const money = Money.fromDollars(10).unwrap()\n      expect(money.isPositive()).toBe(true)\n    })\n\n    it('should return false for zero amount', () => {\n      const money = Money.zero()\n      expect(money.isPositive()).toBe(false)\n    })\n  })\n\n  describe('equals', () => {\n    it('should return true for equal amounts', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(10).unwrap()\n      expect(m1.equals(m2)).toBe(true)\n    })\n\n    it('should return false for different amounts', () => {\n      const m1 = Money.fromDollars(10).unwrap()\n      const m2 = Money.fromDollars(15).unwrap()\n      expect(m1.equals(m2)).toBe(false)\n    })\n\n    it('should return false for different currencies', () => {\n      const m1 = Money.fromDollars(10, 'USD').unwrap()\n      const m2 = Money.fromDollars(10, 'EUR').unwrap()\n      expect(m1.equals(m2)).toBe(false)\n    })\n  })\n\n  describe('toString', () => {\n    it('should format USD correctly', () => {\n      const money = Money.fromDollars(100.5, 'USD').unwrap()\n      expect(money.toString()).toBe('$100.50')\n    })\n  })\n\n  describe('toFormattedString', () => {\n    it('should format with thousands separator', () => {\n      const money = Money.fromDollars(1234567.89, 'USD').unwrap()\n      expect(money.toFormattedString()).toBe('$1,234,567.89')\n    })\n\n    it('should format small amounts correctly', () => {\n      const money = Money.fromDollars(99.99, 'USD').unwrap()\n      expect(money.toFormattedString()).toBe('$99.99')\n    })\n  })\n\n  describe('JSON serialization', () => {\n    it('should serialize to JSON', () => {\n      const money = Money.fromDollars(100.5).unwrap()\n      const json = money.toJSON()\n\n      expect(json.amount).toBe(100.5)\n      expect(json.cents).toBe(10050)\n      expect(json.currency).toBe('USD')\n      expect(json.formatted).toBe('$100.50')\n    })\n\n    it('should deserialize from JSON', () => {\n      const json = { cents: 10050, currency: 'USD' as const }\n      const result = Money.fromJSON(json)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(100.5)\n    })\n  })\n\n  describe('sum', () => {\n    it('should sum multiple money values', () => {\n      const amounts = [\n        Money.fromDollars(10).unwrap(),\n        Money.fromDollars(20).unwrap(),\n        Money.fromDollars(30).unwrap(),\n      ]\n      const result = Money.sum(amounts)\n\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().dollars).toBe(60)\n    })\n\n    it('should return zero for empty array', () => {\n      const result = Money.sum([])\n      expect(result.isOk()).toBe(true)\n      expect(result.unwrap().isZero()).toBe(true)\n    })\n\n    it('should reject mixed currencies', () => {\n      const amounts = [Money.fromDollars(10, 'USD').unwrap(), Money.fromDollars(20, 'EUR').unwrap()]\n      const result = Money.sum(amounts)\n\n      expect(result.isErr()).toBe(true)\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\search\\search-intelligence.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (264). Maximum allowed is 60.",
        "line": 22,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 288,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (122). Maximum allowed is 60.",
        "line": 88,
        "column": 43,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 211,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 94,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 94,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 122,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 122,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [3899, 3902], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [3899, 3902], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 135,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 135,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 148,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 148,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [4847, 4850], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [4847, 4850], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 159,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 159,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 168,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 168,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [5558, 5561], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [5558, 5561], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 179,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 179,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 198,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 198,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [6564, 6567], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [6564, 6567], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (74). Maximum allowed is 60.",
        "line": 213,
        "column": 41,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 287,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 220,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 220,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 238,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 238,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [7872, 7875], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [7872, 7875], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 248,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 248,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 257,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 257,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8535, 8538], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8535, 8538], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/naming-convention",
        "severity": 1,
        "message": "Variable name `GoogleGenerativeAI` must match one of the following formats: camelCase, UPPER_CASE",
        "line": 267,
        "column": 15,
        "nodeType": "Identifier",
        "messageId": "doesNotMatchFormat",
        "endLine": 267,
        "endColumn": 33
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 280,
        "column": 17,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 280,
        "endColumn": 20,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9243, 9246], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9243, 9246], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 17,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Unit tests for AI search intelligence functions\r\n */\r\n\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest'\r\nimport {\r\n  extractLocation,\r\n  extractCaseType,\r\n  processNaturalLanguageQuery,\r\n  generateSearchSuggestions,\r\n} from '@/lib/ai/search-intelligence'\r\n\r\n// Mock Google AI\r\nvi.mock('@google/generative-ai', () => ({\r\n  GoogleGenerativeAI: vi.fn(() => ({\r\n    getGenerativeModel: vi.fn(() => ({\r\n      generateContent: vi.fn(),\r\n    })),\r\n  })),\r\n}))\r\n\r\ndescribe('Search Intelligence', () => {\r\n  describe('extractLocation', () => {\r\n    it('should extract Los Angeles from query', () => {\r\n      const result = extractLocation('Find judges in Los Angeles')\r\n      expect(result).toBe('Los Angeles')\r\n    })\r\n\r\n    it('should extract LA abbreviation', () => {\r\n      const result = extractLocation('Judges in LA county')\r\n      expect(result).toBe('LA')\r\n    })\r\n\r\n    it('should extract Orange County', () => {\r\n      const result = extractLocation('Orange County courts')\r\n      expect(result).toBe('Orange County')\r\n    })\r\n\r\n    it('should extract San Francisco', () => {\r\n      const result = extractLocation('san francisco judges')\r\n      expect(result).toBe('San Francisco')\r\n    })\r\n\r\n    it('should return null for no location match', () => {\r\n      const result = extractLocation('criminal law judges')\r\n      expect(result).toBeNull()\r\n    })\r\n\r\n    it('should be case insensitive', () => {\r\n      const result = extractLocation('ORANGE COUNTY')\r\n      expect(result).toBe('Orange County')\r\n    })\r\n  })\r\n\r\n  describe('extractCaseType', () => {\r\n    it('should extract criminal case type', () => {\r\n      const result = extractCaseType('criminal defense lawyers')\r\n      expect(result).toBe('criminal')\r\n    })\r\n\r\n    it('should extract civil case type', () => {\r\n      const result = extractCaseType('civil litigation judge')\r\n      expect(result).toBe('civil')\r\n    })\r\n\r\n    it('should extract family/divorce case type', () => {\r\n      expect(extractCaseType('divorce attorney')).toBe('divorce')\r\n      expect(extractCaseType('family law court')).toBe('family')\r\n      expect(extractCaseType('custody hearing')).toBe('custody')\r\n    })\r\n\r\n    it('should extract probate case type', () => {\r\n      const result = extractCaseType('probate court judge')\r\n      expect(result).toBe('probate')\r\n    })\r\n\r\n    it('should return null for no case type match', () => {\r\n      const result = extractCaseType('Judge Smith')\r\n      expect(result).toBeNull()\r\n    })\r\n\r\n    it('should be case insensitive', () => {\r\n      const result = extractCaseType('CRIMINAL COURT')\r\n      expect(result).toBe('criminal')\r\n    })\r\n  })\r\n\r\n  describe('processNaturalLanguageQuery', () => {\r\n    beforeEach(() => {\r\n      vi.clearAllMocks()\r\n    })\r\n\r\n    it('should process query with AI successfully', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockResolvedValue({\r\n        response: {\r\n          text: () =>\r\n            JSON.stringify({\r\n              intent: {\r\n                type: 'judge',\r\n                searchType: 'name',\r\n                extractedEntities: {\r\n                  names: ['Judge Smith'],\r\n                  locations: ['Los Angeles'],\r\n                },\r\n                confidence: 0.95,\r\n              },\r\n              processedQuery: 'Judge Smith Los Angeles',\r\n              expandedTerms: ['Smith', 'J. Smith'],\r\n              suggestions: ['Try searching for Judge Smith in Los Angeles Superior Court'],\r\n              conversationalResponse: \"I understand you're looking for Judge Smith in Los Angeles.\",\r\n            }),\r\n        },\r\n      })\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await processNaturalLanguageQuery('Find Judge Smith in LA')\r\n\r\n      expect(result.originalQuery).toBe('Find Judge Smith in LA')\r\n      expect(result.searchIntent.type).toBe('judge')\r\n      expect(result.searchIntent.searchType).toBe('name')\r\n      expect(result.searchIntent.extractedEntities.names).toContain('Judge Smith')\r\n      expect(result.suggestions.length).toBeGreaterThan(0)\r\n    })\r\n\r\n    it('should handle AI parsing errors gracefully', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockResolvedValue({\r\n        response: {\r\n          text: () => 'Invalid JSON response',\r\n        },\r\n      })\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await processNaturalLanguageQuery('criminal judges')\r\n\r\n      // Should return fallback enhancement\r\n      expect(result.originalQuery).toBe('criminal judges')\r\n      expect(result.searchIntent.confidence).toBeLessThan(1)\r\n    })\r\n\r\n    it('should handle AI API errors gracefully', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockRejectedValue(new Error('API Error'))\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await processNaturalLanguageQuery('find judges')\r\n\r\n      // Should return fallback enhancement\r\n      expect(result.originalQuery).toBe('find judges')\r\n      expect(result.searchIntent).toBeDefined()\r\n    })\r\n\r\n    it('should include context in query processing', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockResolvedValue({\r\n        response: {\r\n          text: () =>\r\n            JSON.stringify({\r\n              intent: { type: 'judge', searchType: 'location', extractedEntities: {}, confidence: 0.8 },\r\n              processedQuery: 'judges near me',\r\n              expandedTerms: [],\r\n              suggestions: [],\r\n            }),\r\n        },\r\n      })\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await processNaturalLanguageQuery('judges near me', {\r\n        userLocation: 'Los Angeles',\r\n        previousQueries: ['criminal courts'],\r\n      })\r\n\r\n      expect(mockGenerateContent).toHaveBeenCalled()\r\n      const callArgs = mockGenerateContent.mock.calls[0][0]\r\n      expect(callArgs).toContain('Los Angeles')\r\n      expect(callArgs).toContain('criminal courts')\r\n    })\r\n  })\r\n\r\n  describe('generateSearchSuggestions', () => {\r\n    it('should return empty array for very short queries', async () => {\r\n      const result = await generateSearchSuggestions('a')\r\n      expect(result).toEqual([])\r\n    })\r\n\r\n    it('should generate suggestions with AI', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockResolvedValue({\r\n        response: {\r\n          text: () =>\r\n            JSON.stringify([\r\n              'Judge Smith Los Angeles',\r\n              'Judge Smith Orange County',\r\n              'Criminal Court Judge Smith',\r\n            ]),\r\n        },\r\n      })\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await generateSearchSuggestions('Judge Smith', ['previous search'])\r\n\r\n      expect(Array.isArray(result)).toBe(true)\r\n      expect(result.length).toBeGreaterThan(0)\r\n    })\r\n\r\n    it('should fallback to static suggestions on error', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockRejectedValue(new Error('API Error'))\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await generateSearchSuggestions('judge')\r\n\r\n      expect(Array.isArray(result)).toBe(true)\r\n      // Should still return some suggestions from static fallback\r\n    })\r\n\r\n    it('should handle malformed AI responses', async () => {\r\n      const { GoogleGenerativeAI } = await import('@google/generative-ai')\r\n      const mockGenerateContent = vi.fn().mockResolvedValue({\r\n        response: {\r\n          text: () => 'Not valid JSON',\r\n        },\r\n      })\r\n\r\n      vi.mocked(GoogleGenerativeAI).mockImplementation(\r\n        () =>\r\n          ({\r\n            getGenerativeModel: () => ({\r\n              generateContent: mockGenerateContent,\r\n            }),\r\n          }) as any\r\n      )\r\n\r\n      const result = await generateSearchSuggestions('civil')\r\n\r\n      expect(Array.isArray(result)).toBe(true)\r\n    })\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\utils\\judge-matching.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (336). Maximum allowed is 60.",
        "line": 25,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 360,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 47,
        "column": 36,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 47,
        "endColumn": 39,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1637, 1640], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1637, 1640], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 48,
        "column": 41,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 48,
        "endColumn": 44,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1692, 1695], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1692, 1695], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (74). Maximum allowed is 60.",
        "line": 57,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 130,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 228,
        "column": 35,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 228,
        "endColumn": 38,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [8360, 8363], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [8360, 8363], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 274,
        "column": 34,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 274,
        "endColumn": 37,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9916, 9919], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9916, 9919], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 275,
        "column": 39,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 275,
        "endColumn": 42,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [9972, 9975], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [9972, 9975], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 7,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for judge name matching and normalization\n * Tests the critical business logic for matching judge names with 95%+ accuracy\n *\n * Key requirements:\n * - Handle name variants (Jr., III, hyphenated names)\n * - Normalize names for consistent comparison\n * - Generate name variations for database lookup\n * - Test hierarchical fallback mechanisms\n */\n\nimport { describe, it, expect } from 'vitest'\nimport {\n  normalizeName,\n  generateNameVariations,\n  parseJudgeName,\n  generateSlug,\n  isValidSlug,\n  createCanonicalSlug,\n  generateSlugVariations,\n  isValidSlugVariation,\n  slugToName,\n} from '@/lib/utils/slug'\n\ndescribe('Judge Name Matching', () => {\n  describe('normalizeName', () => {\n    it('should normalize basic names correctly', () => {\n      expect(normalizeName('John Smith')).toBe('John Smith')\n      expect(normalizeName('  John  Smith  ')).toBe('John Smith')\n      expect(normalizeName('JOHN SMITH')).toBe('JOHN SMITH')\n    })\n\n    it('should handle multiple spaces correctly', () => {\n      expect(normalizeName('Allen  L. Norris')).toBe('Allen L. Norris')\n      expect(normalizeName('John   Robert    Smith')).toBe('John Robert Smith')\n    })\n\n    it('should preserve initials with periods', () => {\n      expect(normalizeName('Mary K. Johnson')).toBe('Mary K. Johnson')\n      expect(normalizeName('J. Michael Anderson')).toBe('J. Michael Anderson')\n      expect(normalizeName('A.B.C. Washington')).toBe('A.B.C. Washington')\n    })\n\n    it('should handle empty or invalid input', () => {\n      expect(normalizeName('')).toBe('')\n      expect(normalizeName('   ')).toBe('')\n      expect(normalizeName(null as any)).toBe('')\n      expect(normalizeName(undefined as any)).toBe('')\n    })\n\n    it('should remove excessive periods', () => {\n      expect(normalizeName('J... Smith')).toBe('J. Smith')\n      expect(normalizeName('Mary K.... Johnson')).toBe('Mary K. Johnson')\n    })\n  })\n\n  describe('parseJudgeName', () => {\n    it('should parse simple two-part names', () => {\n      const result = parseJudgeName('John Smith')\n      expect(result.firstName).toBe('John')\n      expect(result.lastName).toBe('Smith')\n      expect(result.middleName).toBeUndefined()\n      expect(result.suffix).toBeUndefined()\n    })\n\n    it('should parse names with middle names', () => {\n      const result = parseJudgeName('John Robert Smith')\n      expect(result.firstName).toBe('John')\n      expect(result.middleName).toBe('Robert')\n      expect(result.lastName).toBe('Smith')\n    })\n\n    it('should parse names with middle initials', () => {\n      const result = parseJudgeName('Mary K. Johnson')\n      expect(result.firstName).toBe('Mary')\n      expect(result.lastName).toBe('Johnson')\n      expect(result.initials).toContain('K')\n    })\n\n    it('should handle Jr. suffix correctly', () => {\n      const result = parseJudgeName('William James Thompson Jr.')\n      expect(result.firstName).toBe('William')\n      expect(result.middleName).toBe('James')\n      expect(result.lastName).toBe('Thompson')\n      expect(result.suffix).toBe('Jr.')\n    })\n\n    it('should handle Roman numeral suffixes (III)', () => {\n      const result = parseJudgeName('Charles Edward Reynolds III')\n      expect(result.firstName).toBe('Charles')\n      expect(result.middleName).toBe('Edward')\n      expect(result.lastName).toBe('Reynolds')\n      expect(result.suffix).toBe('III')\n    })\n\n    it('should handle Sr. suffix', () => {\n      const result = parseJudgeName('Robert Davis Sr.')\n      expect(result.firstName).toBe('Robert')\n      expect(result.lastName).toBe('Davis')\n      expect(result.suffix).toBe('Sr.')\n    })\n\n    it('should handle hyphenated last names', () => {\n      const result = parseJudgeName('Jennifer Anne Parker-Williams')\n      expect(result.firstName).toBe('Jennifer')\n      expect(result.middleName).toBe('Anne')\n      expect(result.lastName).toBe('Parker-Williams')\n    })\n\n    it('should handle single letter first names', () => {\n      const result = parseJudgeName('J. Michael Anderson')\n      expect(result.firstName).toBe('J.')\n      expect(result.lastName).toBe('Anderson')\n      expect(result.initials).toContain('J')\n    })\n\n    it('should handle multiple initials', () => {\n      const result = parseJudgeName('A. B. C. Washington')\n      expect(result.firstName).toBe('A.')\n      expect(result.lastName).toBe('Washington')\n      expect(result.initials.length).toBeGreaterThan(0)\n    })\n\n    it('should return empty structure for invalid input', () => {\n      const result = parseJudgeName('')\n      expect(result.firstName).toBe('')\n      expect(result.lastName).toBe('')\n      expect(result.initials).toEqual([])\n    })\n  })\n\n  describe('generateNameVariations', () => {\n    it('should generate variations for simple names', () => {\n      const variations = generateNameVariations('John Smith')\n      expect(variations).toContain('John Smith')\n      expect(variations.length).toBeGreaterThan(1)\n    })\n\n    it('should handle double space variations', () => {\n      const variations = generateNameVariations('Allen L. Norris')\n      expect(variations).toContain('Allen L. Norris')\n      expect(variations).toContain('Allen  L. Norris')\n      expect(variations.some((v) => v.includes('Allen  L.'))).toBe(true)\n    })\n\n    it('should generate variations without periods', () => {\n      const variations = generateNameVariations('Mary K. Johnson')\n      expect(variations).toContain('Mary K. Johnson')\n      expect(variations).toContain('Mary K Johnson')\n    })\n\n    it('should generate first-last only variations', () => {\n      const variations = generateNameVariations('John Robert Smith')\n      expect(variations).toContain('John Smith')\n    })\n\n    it('should generate reversed name format', () => {\n      const variations = generateNameVariations('John Smith')\n      expect(variations).toContain('Smith, John')\n    })\n\n    it('should limit variations to prevent excessive queries', () => {\n      const variations = generateNameVariations('A. B. C. D. E. F. Washington')\n      expect(variations.length).toBeLessThanOrEqual(20)\n    })\n\n    it('should filter out empty variations', () => {\n      const variations = generateNameVariations('John Smith')\n      expect(variations.every((v) => v.trim().length > 0)).toBe(true)\n    })\n\n    it('should handle names with Jr. suffix', () => {\n      const variations = generateNameVariations('William Thompson Jr.')\n      expect(variations.length).toBeGreaterThan(1)\n      expect(variations.some((v) => v.includes('Jr'))).toBe(true)\n    })\n\n    it('should normalize spacing variations', () => {\n      const variations = generateNameVariations('John  Smith')\n      expect(variations).toContain('John Smith')\n    })\n\n    it('should handle hyphenated names', () => {\n      const variations = generateNameVariations('Parker-Williams')\n      expect(variations).toContain('Parker-Williams')\n    })\n  })\n\n  describe('generateSlug', () => {\n    it('should generate valid slugs for simple names', () => {\n      expect(generateSlug('John Smith')).toBe('john-smith')\n      expect(generateSlug('Mary Johnson')).toBe('mary-johnson')\n    })\n\n    it('should handle names with middle names', () => {\n      expect(generateSlug('John Robert Smith')).toBe('john-robert-smith')\n    })\n\n    it('should handle names with initials', () => {\n      expect(generateSlug('Mary K. Johnson')).toBe('mary-k-johnson')\n      expect(generateSlug('J. Michael Anderson')).toBe('j-michael-anderson')\n    })\n\n    it('should handle Jr. suffix', () => {\n      expect(generateSlug('William Thompson Jr.')).toBe('william-thompson-jr')\n    })\n\n    it('should handle III suffix', () => {\n      expect(generateSlug('Charles Reynolds III')).toBe('charles-reynolds-iii')\n    })\n\n    it('should handle hyphenated names', () => {\n      expect(generateSlug('Jennifer Parker-Williams')).toBe('jennifer-parkerwilliams')\n    })\n\n    it('should remove special characters', () => {\n      expect(generateSlug(\"O'Connor\")).toBe('oconnor')\n      expect(generateSlug('Smith, Jr.')).toBe('smith-jr')\n    })\n\n    it('should handle multiple consecutive spaces', () => {\n      expect(generateSlug('John  Robert  Smith')).toBe('john-robert-smith')\n    })\n\n    it('should return fallback for invalid input', () => {\n      expect(generateSlug('')).toBe('unknown-judge')\n      expect(generateSlug('   ')).toBe('unknown-judge')\n      expect(generateSlug(null as any)).toBe('unknown-judge')\n    })\n\n    it('should convert to lowercase', () => {\n      expect(generateSlug('JOHN SMITH')).toBe('john-smith')\n    })\n\n    it('should remove leading and trailing hyphens', () => {\n      expect(generateSlug('-John Smith-')).toBe('john-smith')\n    })\n\n    it('should replace multiple hyphens with single hyphen', () => {\n      const slug = generateSlug('John---Smith')\n      expect(slug).not.toContain('---')\n      expect(slug).toBe('john-smith')\n    })\n  })\n\n  describe('isValidSlug', () => {\n    it('should validate correct slugs', () => {\n      expect(isValidSlug('john-smith')).toBe(true)\n      expect(isValidSlug('mary-k-johnson')).toBe(true)\n      expect(isValidSlug('william-thompson-jr')).toBe(true)\n    })\n\n    it('should reject invalid slugs', () => {\n      expect(isValidSlug('')).toBe(false)\n      expect(isValidSlug('John Smith')).toBe(false)\n      expect(isValidSlug('john_smith')).toBe(false)\n      expect(isValidSlug('john--smith')).toBe(false)\n      expect(isValidSlug('-john-smith')).toBe(false)\n      expect(isValidSlug('john-smith-')).toBe(false)\n    })\n\n    it('should enforce length requirements', () => {\n      expect(isValidSlug('j')).toBe(false)\n      expect(isValidSlug('j'.repeat(101))).toBe(false)\n      expect(isValidSlug('john-smith')).toBe(true)\n    })\n\n    it('should allow numbers in slugs', () => {\n      expect(isValidSlug('judge-123')).toBe(true)\n      expect(isValidSlug('john-smith-2')).toBe(true)\n    })\n\n    it('should reject null or undefined', () => {\n      expect(isValidSlug(null as any)).toBe(false)\n      expect(isValidSlug(undefined as any)).toBe(false)\n    })\n  })\n\n  describe('createCanonicalSlug', () => {\n    it('should create canonical slugs', () => {\n      expect(createCanonicalSlug('John Robert Smith')).toBe('john-robert-smith')\n      expect(createCanonicalSlug('Mary K. Johnson')).toBe('mary-k-johnson')\n    })\n\n    it('should include suffixes in canonical slug', () => {\n      expect(createCanonicalSlug('William Thompson Jr.')).toBe('william-thompson-jr')\n      expect(createCanonicalSlug('Charles Reynolds III')).toBe('charles-reynolds-iii')\n    })\n\n    it('should handle edge cases gracefully', () => {\n      const slug = createCanonicalSlug('')\n      expect(slug).toBe('unknown-judge')\n    })\n  })\n\n  describe('generateSlugVariations', () => {\n    it('should include canonical slug first', () => {\n      const variations = generateSlugVariations('John Robert Smith')\n      expect(variations[0]).toBe('john-robert-smith')\n    })\n\n    it('should generate variations with titles', () => {\n      const variations = generateSlugVariations('John Smith')\n      expect(variations).toContain('judge-john-smith')\n      expect(variations).toContain('justice-john-smith')\n    })\n\n    it('should generate first-last only variation', () => {\n      const variations = generateSlugVariations('John Robert Smith')\n      expect(variations).toContain('john-smith')\n    })\n\n    it('should filter out invalid slugs', () => {\n      const variations = generateSlugVariations('John Smith')\n      expect(variations.every((slug) => isValidSlug(slug))).toBe(true)\n    })\n\n    it('should deduplicate variations', () => {\n      const variations = generateSlugVariations('John Smith')\n      const uniqueVariations = [...new Set(variations)]\n      expect(variations.length).toBe(uniqueVariations.length)\n    })\n  })\n\n  describe('isValidSlugVariation', () => {\n    it('should validate slug variations', () => {\n      expect(isValidSlugVariation('john-smith', 'John Smith')).toBe(true)\n      expect(isValidSlugVariation('judge-john-smith', 'John Smith')).toBe(true)\n    })\n\n    it('should reject invalid variations', () => {\n      expect(isValidSlugVariation('jane-doe', 'John Smith')).toBe(false)\n      expect(isValidSlugVariation('invalid slug', 'John Smith')).toBe(false)\n    })\n\n    it('should handle empty input', () => {\n      expect(isValidSlugVariation('', 'John Smith')).toBe(false)\n      expect(isValidSlugVariation('john-smith', '')).toBe(false)\n    })\n  })\n\n  describe('slugToName', () => {\n    it('should convert slug to readable name', () => {\n      expect(slugToName('john-smith')).toBe('John Smith')\n      expect(slugToName('mary-k-johnson')).toBe('Mary K. Johnson')\n    })\n\n    it('should handle initials correctly', () => {\n      expect(slugToName('j-michael-anderson')).toBe('J. Michael Anderson')\n    })\n\n    it('should handle roman numerals', () => {\n      expect(slugToName('charles-reynolds-iii')).toBe('Charles Reynolds III')\n    })\n\n    it('should capitalize each word', () => {\n      expect(slugToName('william-james-thompson')).toBe('William James Thompson')\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\validation\\input-validation.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (140). Maximum allowed is 60.",
        "line": 9,
        "column": 30,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 149,
        "endColumn": 2
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 28,
        "column": 51,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 28,
        "endColumn": 54,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [970, 973], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [970, 973], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 29,
        "column": 56,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 29,
        "endColumn": 59,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [1031, 1034], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [1031, 1034], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\r\n * Unit tests for input validation and sanitization\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest'\r\nimport { sanitizeSearchQuery, normalizeJudgeSearchQuery } from '@/lib/utils/validation'\r\nimport { sanitizeLikePattern } from '@/lib/utils/sql-sanitize'\r\n\r\ndescribe('Input Validation', () => {\r\n  describe('sanitizeSearchQuery', () => {\r\n    it('should remove HTML tags', () => {\r\n      const result = sanitizeSearchQuery('<script>alert(\"xss\")</script>Judge Smith')\r\n      expect(result).not.toContain('<script>')\r\n      expect(result).not.toContain('</script>')\r\n    })\r\n\r\n    it('should trim whitespace', () => {\r\n      const result = sanitizeSearchQuery('  Judge Smith  ')\r\n      expect(result).toBe('Judge Smith')\r\n    })\r\n\r\n    it('should handle empty string', () => {\r\n      const result = sanitizeSearchQuery('')\r\n      expect(result).toBe('')\r\n    })\r\n\r\n    it('should handle null/undefined', () => {\r\n      const result1 = sanitizeSearchQuery(null as any)\r\n      const result2 = sanitizeSearchQuery(undefined as any)\r\n      expect(result1).toBe('')\r\n      expect(result2).toBe('')\r\n    })\r\n\r\n    it('should preserve normal text', () => {\r\n      const result = sanitizeSearchQuery('Judge Smith Los Angeles')\r\n      expect(result).toBe('Judge Smith Los Angeles')\r\n    })\r\n\r\n    it('should remove dangerous characters', () => {\r\n      const result = sanitizeSearchQuery('Judge<>Smith')\r\n      expect(result).not.toContain('<')\r\n      expect(result).not.toContain('>')\r\n    })\r\n\r\n    it('should handle SQL injection attempts', () => {\r\n      const result = sanitizeSearchQuery(\"'; DROP TABLE judges; --\")\r\n      expect(result).not.toContain('DROP TABLE')\r\n    })\r\n  })\r\n\r\n  describe('normalizeJudgeSearchQuery', () => {\r\n    it('should normalize judge name with title', () => {\r\n      const result = normalizeJudgeSearchQuery('Judge John Smith')\r\n      expect(result.toLowerCase()).not.toContain('judge')\r\n      expect(result).toContain('John')\r\n      expect(result).toContain('Smith')\r\n    })\r\n\r\n    it('should normalize variations of judge titles', () => {\r\n      expect(normalizeJudgeSearchQuery('Hon. Smith')).not.toContain('Hon.')\r\n      expect(normalizeJudgeSearchQuery('Justice Smith')).not.toContain('Justice')\r\n      expect(normalizeJudgeSearchQuery('Magistrate Smith')).not.toContain('Magistrate')\r\n    })\r\n\r\n    it('should handle multiple spaces', () => {\r\n      const result = normalizeJudgeSearchQuery('John    Smith')\r\n      expect(result).toBe('John Smith')\r\n    })\r\n\r\n    it('should preserve hyphens in names', () => {\r\n      const result = normalizeJudgeSearchQuery('John-Paul Smith')\r\n      expect(result).toBe('John-Paul Smith')\r\n    })\r\n\r\n    it('should handle apostrophes', () => {\r\n      const result = normalizeJudgeSearchQuery(\"O'Connor\")\r\n      expect(result).toContain(\"O'Connor\")\r\n    })\r\n\r\n    it('should be case insensitive', () => {\r\n      const result = normalizeJudgeSearchQuery('JUDGE SMITH')\r\n      expect(result).not.toMatch(/^JUDGE/)\r\n    })\r\n  })\r\n\r\n  describe('sanitizeLikePattern', () => {\r\n    it('should escape SQL LIKE wildcards', () => {\r\n      const result = sanitizeLikePattern('John%Smith')\r\n      expect(result).not.toContain('%')\r\n    })\r\n\r\n    it('should escape underscore wildcard', () => {\r\n      const result = sanitizeLikePattern('John_Smith')\r\n      expect(result).not.toContain('_')\r\n    })\r\n\r\n    it('should handle normal text without special chars', () => {\r\n      const result = sanitizeLikePattern('John Smith')\r\n      expect(result).toBe('John Smith')\r\n    })\r\n\r\n    it('should handle empty string', () => {\r\n      const result = sanitizeLikePattern('')\r\n      expect(result).toBe('')\r\n    })\r\n\r\n    it('should escape backslashes', () => {\r\n      const result = sanitizeLikePattern('John\\\\Smith')\r\n      expect(result).not.toContain('\\\\')\r\n    })\r\n\r\n    it('should handle multiple special characters', () => {\r\n      const result = sanitizeLikePattern('100% match_test')\r\n      expect(result).not.toContain('%')\r\n      expect(result).not.toContain('_')\r\n    })\r\n\r\n    it('should prevent SQL injection in LIKE clause', () => {\r\n      const malicious = \"test' OR '1'='1\"\r\n      const result = sanitizeLikePattern(malicious)\r\n      // Should escape or remove dangerous patterns\r\n      expect(result).toBeDefined()\r\n    })\r\n  })\r\n\r\n  describe('Integration: Combined Validation', () => {\r\n    it('should safely process user search input end-to-end', () => {\r\n      const userInput = '<script>alert(\"xss\")</script>Judge%Smith_Test'\r\n      const sanitized = sanitizeSearchQuery(userInput)\r\n      const normalized = normalizeJudgeSearchQuery(sanitized)\r\n      const sqlSafe = sanitizeLikePattern(normalized)\r\n\r\n      expect(sqlSafe).not.toContain('<script>')\r\n      expect(sqlSafe).not.toContain('%')\r\n      expect(sqlSafe).not.toContain('_')\r\n    })\r\n\r\n    it('should handle complex real-world input', () => {\r\n      const userInput = '  Hon. John O\\'Brien-Smith (Ret.)  '\r\n      const sanitized = sanitizeSearchQuery(userInput)\r\n      const normalized = normalizeJudgeSearchQuery(sanitized)\r\n\r\n      expect(normalized).toContain('John')\r\n      expect(normalized).toContain(\"O'Brien-Smith\")\r\n      expect(normalized).not.toContain('Hon.')\r\n      expect(normalized).not.toContain('(Ret.)')\r\n    })\r\n  })\r\n})\r\n",
    "usedDeprecatedRules": []
  },
  {
    "filePath": "C:\\Users\\Tanner\\JudgeFinder.io\\JudgeFinderPlatform\\tests\\unit\\validation\\security-validation.test.ts",
    "messages": [
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (400). Maximum allowed is 60.",
        "line": 23,
        "column": 33,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 425,
        "endColumn": 2
      },
      {
        "ruleId": "max-lines-per-function",
        "severity": 1,
        "message": "Arrow function has too many lines (62). Maximum allowed is 60.",
        "line": 24,
        "column": 40,
        "nodeType": "ArrowFunctionExpression",
        "messageId": "exceed",
        "endLine": 85,
        "endColumn": 4
      },
      {
        "ruleId": "@typescript-eslint/no-explicit-any",
        "severity": 1,
        "message": "Unexpected any. Specify a different type.",
        "line": 383,
        "column": 46,
        "nodeType": "TSAnyKeyword",
        "messageId": "unexpectedAny",
        "endLine": 383,
        "endColumn": 49,
        "suggestions": [
          {
            "messageId": "suggestUnknown",
            "fix": { "range": [13042, 13045], "text": "unknown" },
            "desc": "Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."
          },
          {
            "messageId": "suggestNever",
            "fix": { "range": [13042, 13045], "text": "never" },
            "desc": "Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."
          }
        ]
      }
    ],
    "suppressedMessages": [],
    "errorCount": 0,
    "fatalErrorCount": 0,
    "warningCount": 3,
    "fixableErrorCount": 0,
    "fixableWarningCount": 0,
    "source": "/**\n * Unit tests for input validation and security\n * Tests XSS prevention, SQL injection prevention, and input sanitization\n * CRITICAL: These tests ensure production security\n */\n\nimport { describe, it, expect } from 'vitest'\nimport {\n  isValidUUID,\n  isValidSlug,\n  sanitizeSearchQuery,\n  normalizeJudgeSearchQuery,\n  slugSchema,\n  searchQuerySchema,\n  judgeSearchParamsSchema,\n  courtSearchParamsSchema,\n  analyticsParamsSchema,\n  paginationSchema,\n  jurisdictionSchema,\n  validateParams,\n} from '@/lib/utils/validation'\n\ndescribe('Security Validation', () => {\n  describe('XSS Payload Sanitization', () => {\n    it('should remove script tags from search queries', () => {\n      const malicious = '<script>alert(\"xss\")</script>John Smith'\n      const sanitized = sanitizeSearchQuery(malicious)\n      expect(sanitized).not.toContain('<script>')\n      expect(sanitized).not.toContain('</script>')\n    })\n\n    it('should remove angle brackets to prevent XSS', () => {\n      const malicious = '<img src=x onerror=alert(1)>'\n      const sanitized = sanitizeSearchQuery(malicious)\n      expect(sanitized).not.toContain('<')\n      expect(sanitized).not.toContain('>')\n    })\n\n    it('should handle common XSS attack vectors', () => {\n      const attacks = [\n        '<script>alert(document.cookie)</script>',\n        '<img src=x onerror=alert(1)>',\n        '<svg/onload=alert(1)>',\n        'javascript:alert(1)',\n        '<iframe src=\"javascript:alert(1)\">',\n      ]\n\n      attacks.forEach((attack) => {\n        const sanitized = sanitizeSearchQuery(attack)\n        expect(sanitized).not.toContain('<')\n        expect(sanitized).not.toContain('>')\n        expect(sanitized).not.toContain('script')\n      })\n    })\n\n    it('should limit length to prevent DoS attacks', () => {\n      const longString = 'a'.repeat(1000)\n      const sanitized = sanitizeSearchQuery(longString)\n      expect(sanitized.length).toBeLessThanOrEqual(100)\n    })\n\n    it('should trim whitespace', () => {\n      const query = '  John Smith  '\n      const sanitized = sanitizeSearchQuery(query)\n      expect(sanitized).toBe('John Smith')\n    })\n\n    it('should preserve valid search terms', () => {\n      const validQuery = 'John Robert Smith Jr.'\n      const sanitized = sanitizeSearchQuery(validQuery)\n      expect(sanitized).toBe('John Robert Smith Jr.')\n    })\n\n    it('should handle encoded XSS attempts', () => {\n      const encoded = '%3Cscript%3Ealert(1)%3C/script%3E'\n      const sanitized = sanitizeSearchQuery(encoded)\n      expect(sanitized).not.toContain('<script>')\n    })\n\n    it('should handle null bytes and control characters', () => {\n      const malicious = 'John\\x00Smith\\x01Test'\n      const sanitized = sanitizeSearchQuery(malicious)\n      expect(sanitized).toBeTruthy()\n    })\n  })\n\n  describe('SQL Injection Prevention', () => {\n    it('should reject SQL injection in search params', () => {\n      const sqlInjection = \"'; DROP TABLE judges; --\"\n      const result = searchQuerySchema.safeParse(sqlInjection)\n      expect(result.success).toBe(true) // Schema allows it, but DB layer should use parameterized queries\n\n      // Verify sanitization happens\n      const sanitized = sanitizeSearchQuery(sqlInjection)\n      expect(sanitized).not.toContain(';')\n    })\n\n    it('should reject SQL keywords in slug', () => {\n      const sqlSlug = 'john-smith-union-select'\n      const result = slugSchema.safeParse(sqlSlug)\n      expect(result.success).toBe(true) // Valid slug format\n      // SQL injection prevention relies on parameterized queries at DB layer\n    })\n\n    it('should handle SQL injection attempts in UUID', () => {\n      const invalidUUID = \"1' OR '1'='1\"\n      expect(isValidUUID(invalidUUID)).toBe(false)\n    })\n\n    it('should reject malformed UUIDs', () => {\n      const invalid = [\n        '',\n        'not-a-uuid',\n        '12345',\n        'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx',\n        '00000000-0000-0000-0000-000000000000g',\n      ]\n\n      invalid.forEach((uuid) => {\n        expect(isValidUUID(uuid)).toBe(false)\n      })\n    })\n\n    it('should accept valid UUIDs only', () => {\n      const validUUIDs = [\n        '550e8400-e29b-41d4-a716-446655440000',\n        'f47ac10b-58cc-4372-a567-0e02b2c3d479',\n        'c9bf9e57-1685-4c89-bafb-ff5af830be8a',\n      ]\n\n      validUUIDs.forEach((uuid) => {\n        expect(isValidUUID(uuid)).toBe(true)\n      })\n    })\n  })\n\n  describe('UUID Format Validation', () => {\n    it('should validate correct UUID v4 format', () => {\n      const valid = '123e4567-e89b-12d3-a456-426614174000'\n      expect(isValidUUID(valid)).toBe(true)\n    })\n\n    it('should reject UUIDs with wrong version', () => {\n      // UUID v1, v2, v3 format (version bit != 4)\n      const wrongVersion = '123e4567-e89b-72d3-a456-426614174000' // Version 7\n      expect(isValidUUID(wrongVersion)).toBe(false)\n    })\n\n    it('should reject UUIDs with wrong variant', () => {\n      const wrongVariant = '123e4567-e89b-42d3-1456-426614174000' // Variant bits wrong\n      expect(isValidUUID(wrongVariant)).toBe(false)\n    })\n\n    it('should handle case insensitivity', () => {\n      const uppercase = '550E8400-E29B-41D4-A716-446655440000'\n      const lowercase = '550e8400-e29b-41d4-a716-446655440000'\n      expect(isValidUUID(uppercase)).toBe(true)\n      expect(isValidUUID(lowercase)).toBe(true)\n    })\n\n    it('should reject UUIDs with invalid characters', () => {\n      const invalidChar = '550e8400-e29b-41d4-a716-44665544000g'\n      expect(isValidUUID(invalidChar)).toBe(false)\n    })\n\n    it('should reject UUIDs with wrong length', () => {\n      const tooShort = '550e8400-e29b-41d4-a716-44665544000'\n      const tooLong = '550e8400-e29b-41d4-a716-4466554400000'\n      expect(isValidUUID(tooShort)).toBe(false)\n      expect(isValidUUID(tooLong)).toBe(false)\n    })\n\n    it('should reject UUIDs with missing hyphens', () => {\n      const noHyphens = '550e8400e29b41d4a716446655440000'\n      expect(isValidUUID(noHyphens)).toBe(false)\n    })\n\n    it('should reject UUIDs with extra hyphens', () => {\n      const extraHyphens = '550e-8400-e29b-41d4-a716-446655440000'\n      expect(isValidUUID(extraHyphens)).toBe(false)\n    })\n  })\n\n  describe('Slug Validation', () => {\n    it('should validate correct slug format', () => {\n      expect(isValidSlug('john-smith')).toBe(true)\n      expect(isValidSlug('mary-k-johnson')).toBe(true)\n      expect(isValidSlug('judge-123')).toBe(true)\n    })\n\n    it('should reject slugs with uppercase letters', () => {\n      expect(isValidSlug('John-Smith')).toBe(false)\n      expect(isValidSlug('JOHN-SMITH')).toBe(false)\n    })\n\n    it('should reject slugs with special characters', () => {\n      expect(isValidSlug('john_smith')).toBe(false)\n      expect(isValidSlug('john.smith')).toBe(false)\n      expect(isValidSlug('john@smith')).toBe(false)\n      expect(isValidSlug('john smith')).toBe(false)\n    })\n\n    it('should reject empty or too short slugs', () => {\n      expect(isValidSlug('')).toBe(false)\n      expect(isValidSlug('a')).toBe(false) // Too short based on validation\n    })\n\n    it('should reject slugs exceeding max length', () => {\n      const tooLong = 'a'.repeat(201)\n      expect(isValidSlug(tooLong)).toBe(false)\n    })\n\n    it('should reject slugs with leading/trailing hyphens', () => {\n      expect(isValidSlug('-john-smith')).toBe(false)\n      expect(isValidSlug('john-smith-')).toBe(false)\n    })\n\n    it('should reject slugs with consecutive hyphens', () => {\n      expect(isValidSlug('john--smith')).toBe(false)\n      expect(isValidSlug('john---smith')).toBe(false)\n    })\n  })\n\n  describe('Search Query Normalization', () => {\n    it('should remove common noise words (judge, judges)', () => {\n      expect(normalizeJudgeSearchQuery('judge John Smith')).toBe('John Smith')\n      expect(normalizeJudgeSearchQuery('judges in california')).toBe('in california')\n    })\n\n    it('should handle case-insensitive noise word removal', () => {\n      expect(normalizeJudgeSearchQuery('JUDGE John Smith')).toBe('John Smith')\n      expect(normalizeJudgeSearchQuery('Judge JOHN SMITH')).toBe('JOHN SMITH')\n    })\n\n    it('should collapse multiple spaces', () => {\n      expect(normalizeJudgeSearchQuery('John   Robert    Smith')).toBe('John Robert Smith')\n    })\n\n    it('should preserve valid search terms after sanitization', () => {\n      const query = 'Mary K. Johnson'\n      expect(normalizeJudgeSearchQuery(query)).toBe('Mary K. Johnson')\n    })\n\n    it('should return sanitized input if cleaning strips everything', () => {\n      const result = normalizeJudgeSearchQuery('judge judges')\n      expect(result.length).toBeGreaterThan(0)\n    })\n\n    it('should handle XSS attempts', () => {\n      const malicious = '<script>judge alert(1)</script>'\n      const normalized = normalizeJudgeSearchQuery(malicious)\n      expect(normalized).not.toContain('<script>')\n    })\n  })\n\n  describe('Schema Validation - Judge Search Params', () => {\n    it('should validate correct judge search params', () => {\n      const params = {\n        q: 'John Smith',\n        limit: 20,\n        page: 1,\n        jurisdiction: 'CA',\n      }\n      const result = judgeSearchParamsSchema.safeParse(params)\n      expect(result.success).toBe(true)\n    })\n\n    it('should apply default values', () => {\n      const params = { q: 'John Smith' }\n      const result = judgeSearchParamsSchema.safeParse(params)\n      expect(result.success).toBe(true)\n      if (result.success) {\n        expect(result.data.limit).toBe(20)\n        expect(result.data.page).toBe(1)\n      }\n    })\n\n    it('should reject invalid limit values', () => {\n      const params = { limit: 101 }\n      const result = judgeSearchParamsSchema.safeParse(params)\n      expect(result.success).toBe(false)\n    })\n\n    it('should reject invalid page values', () => {\n      const params = { page: 0 }\n      const result = judgeSearchParamsSchema.safeParse(params)\n      expect(result.success).toBe(false)\n    })\n\n    it('should reject invalid court_id format', () => {\n      const params = { court_id: 'not-a-uuid' }\n      const result = judgeSearchParamsSchema.safeParse(params)\n      expect(result.success).toBe(false)\n    })\n\n    it('should coerce string numbers', () => {\n      const params = { limit: '25', page: '2' }\n      const result = judgeSearchParamsSchema.safeParse(params)\n      expect(result.success).toBe(true)\n      if (result.success) {\n        expect(result.data.limit).toBe(25)\n        expect(result.data.page).toBe(2)\n      }\n    })\n  })\n\n  describe('Schema Validation - Pagination', () => {\n    it('should enforce minimum page number', () => {\n      const result = paginationSchema.safeParse({ page: 0, limit: 20 })\n      expect(result.success).toBe(false)\n    })\n\n    it('should enforce maximum limit', () => {\n      const result = paginationSchema.safeParse({ page: 1, limit: 101 })\n      expect(result.success).toBe(false)\n    })\n\n    it('should apply defaults', () => {\n      const result = paginationSchema.safeParse({})\n      expect(result.success).toBe(true)\n      if (result.success) {\n        expect(result.data.page).toBe(1)\n        expect(result.data.limit).toBe(20)\n      }\n    })\n  })\n\n  describe('Schema Validation - Jurisdiction', () => {\n    it('should validate correct jurisdiction codes', () => {\n      const valid = ['CA', 'NY', 'TX', 'F', 'USA']\n      valid.forEach((code) => {\n        const result = jurisdictionSchema.safeParse(code)\n        expect(result.success).toBe(true)\n      })\n    })\n\n    it('should reject lowercase jurisdiction codes', () => {\n      const result = jurisdictionSchema.safeParse('ca')\n      expect(result.success).toBe(false)\n    })\n\n    it('should reject jurisdiction codes with special characters', () => {\n      const result = jurisdictionSchema.safeParse('CA-1')\n      expect(result.success).toBe(false)\n    })\n\n    it('should enforce minimum length', () => {\n      const result = jurisdictionSchema.safeParse('C')\n      expect(result.success).toBe(false)\n    })\n\n    it('should enforce maximum length', () => {\n      const result = jurisdictionSchema.safeParse('TOOLONGCODE')\n      expect(result.success).toBe(false)\n    })\n  })\n\n  describe('validateParams Helper', () => {\n    it('should return success for valid params', () => {\n      const result = validateParams(\n        judgeSearchParamsSchema,\n        { q: 'John Smith', limit: 20, page: 1 },\n        'test'\n      )\n      expect(result.success).toBe(true)\n      if (result.success) {\n        expect(result.data.q).toBe('John Smith')\n      }\n    })\n\n    it('should return error response for invalid params', () => {\n      const result = validateParams(judgeSearchParamsSchema, { limit: 101 }, 'test')\n      expect(result.success).toBe(false)\n      if (!result.success) {\n        expect(result.response.status).toBe(400)\n      }\n    })\n\n    it('should include validation errors in response', () => {\n      const result = validateParams(analyticsParamsSchema, { id: 'not-a-uuid' }, 'test')\n      expect(result.success).toBe(false)\n      if (!result.success) {\n        const json = result.response.json as any\n        expect(json).toBeTruthy()\n      }\n    })\n  })\n\n  describe('Edge Cases and Attack Vectors', () => {\n    it('should handle null input', () => {\n      const result = searchQuerySchema.safeParse(null)\n      expect(result.success).toBe(false)\n    })\n\n    it('should handle undefined input', () => {\n      const result = searchQuerySchema.safeParse(undefined)\n      expect(result.success).toBe(false)\n    })\n\n    it('should handle numeric input where string expected', () => {\n      const result = slugSchema.safeParse(12345)\n      expect(result.success).toBe(false)\n    })\n\n    it('should handle object input where string expected', () => {\n      const result = slugSchema.safeParse({ name: 'john-smith' })\n      expect(result.success).toBe(false)\n    })\n\n    it('should handle array input', () => {\n      const result = slugSchema.safeParse(['john-smith'])\n      expect(result.success).toBe(false)\n    })\n\n    it('should reject negative numbers in pagination', () => {\n      const result = paginationSchema.safeParse({ page: -1, limit: -10 })\n      expect(result.success).toBe(false)\n    })\n\n    it('should reject float numbers where integers expected', () => {\n      const result = paginationSchema.safeParse({ page: 1.5, limit: 20.7 })\n      expect(result.success).toBe(false)\n    })\n  })\n})\n",
    "usedDeprecatedRules": []
  }
]
