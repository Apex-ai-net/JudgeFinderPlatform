-- Migration: Service Account RBAC Setup
-- Version: 20251009_001
-- Description: Creates backend service account infrastructure to reduce reliance on service_role key
--
-- This migration:
-- 1. Creates a backend service user in auth.users
-- 2. Adds is_service_account column to app_users table
-- 3. Creates helper functions for service account identification
-- 4. Sets up policies for service account operations

BEGIN;

-- ============================================================================
-- Step 1: Create Backend Service User
-- ============================================================================
-- Note: This creates a service account user with a deterministic ID
-- The actual JWT for this user will be generated by the application

DO $$
DECLARE
  service_user_id UUID := '00000000-0000-0000-0000-000000000001'; -- Deterministic service account ID
BEGIN
  -- Create service user in auth.users if it doesn't exist
  IF NOT EXISTS (SELECT 1 FROM auth.users WHERE id = service_user_id) THEN
    INSERT INTO auth.users (
      id,
      instance_id,
      aud,
      role,
      email,
      encrypted_password,
      email_confirmed_at,
      created_at,
      updated_at,
      raw_app_meta_data,
      raw_user_meta_data,
      is_super_admin,
      confirmation_token
    ) VALUES (
      service_user_id,
      '00000000-0000-0000-0000-000000000000', -- Default instance
      'authenticated',
      'authenticated', -- Service account is an authenticated user, not service_role
      'service-account@judgefinder.internal',
      crypt('INVALID_PASSWORD_' || gen_random_uuid()::text, gen_salt('bf')), -- Unguessable password
      NOW(),
      NOW(),
      NOW(),
      jsonb_build_object(
        'provider', 'system',
        'service_account', true,
        'description', 'Backend service account for internal operations'
      ),
      jsonb_build_object(
        'name', 'JudgeFinder Backend Service',
        'service_account', true
      ),
      false,
      ''
    );

    RAISE NOTICE 'Created service account user with ID: %', service_user_id;
  ELSE
    RAISE NOTICE 'Service account user already exists with ID: %', service_user_id;
  END IF;
END $$;

-- ============================================================================
-- Step 2: Add Service Account Tracking to app_users
-- ============================================================================

-- Add is_service_account column if it doesn't exist
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = 'public'
    AND table_name = 'app_users'
    AND column_name = 'is_service_account'
  ) THEN
    ALTER TABLE public.app_users
    ADD COLUMN is_service_account BOOLEAN NOT NULL DEFAULT false;

    COMMENT ON COLUMN public.app_users.is_service_account IS
      'Indicates whether this user is a backend service account (not a human user)';

    -- Create index for service account queries
    CREATE INDEX IF NOT EXISTS idx_app_users_service_account
      ON public.app_users(is_service_account)
      WHERE is_service_account = true;

    RAISE NOTICE 'Added is_service_account column to app_users';
  ELSE
    RAISE NOTICE 'is_service_account column already exists in app_users';
  END IF;
END $$;

-- Create app_user record for service account if it doesn't exist
DO $$
DECLARE
  service_user_id UUID := '00000000-0000-0000-0000-000000000001';
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM public.app_users
    WHERE clerk_user_id = service_user_id::text
  ) THEN
    INSERT INTO public.app_users (
      clerk_user_id,
      email,
      full_name,
      is_admin,
      is_service_account,
      created_at,
      updated_at
    ) VALUES (
      service_user_id::text,
      'service-account@judgefinder.internal',
      'Backend Service Account',
      true, -- Service account has admin privileges
      true,
      NOW(),
      NOW()
    );

    RAISE NOTICE 'Created app_user record for service account';
  ELSE
    RAISE NOTICE 'app_user record already exists for service account';
  END IF;
END $$;

-- ============================================================================
-- Step 3: Create Helper Functions
-- ============================================================================

-- Function to check if current user is the service account
CREATE OR REPLACE FUNCTION is_service_account()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.app_users
    WHERE clerk_user_id = auth.uid()::text
    AND is_service_account = true
  );
$$;

COMMENT ON FUNCTION is_service_account() IS
  'Returns true if the current authenticated user is a backend service account';

-- Function to check if current user is an admin
CREATE OR REPLACE FUNCTION is_admin()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.app_users
    WHERE clerk_user_id = auth.uid()::text
    AND is_admin = true
  );
$$;

COMMENT ON FUNCTION is_admin() IS
  'Returns true if the current authenticated user is an admin';

-- Function to get current user's Clerk ID (normalized)
CREATE OR REPLACE FUNCTION current_user_id()
RETURNS TEXT
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT auth.uid()::text;
$$;

COMMENT ON FUNCTION current_user_id() IS
  'Returns the current authenticated user''s Clerk ID as text';

-- Function to check if current role is service_role (for legacy compatibility)
CREATE OR REPLACE FUNCTION is_service_role()
RETURNS BOOLEAN
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT auth.role() = 'service_role';
$$;

COMMENT ON FUNCTION is_service_role() IS
  'Returns true if the current session is using the service_role key (bypasses RLS)';

-- ============================================================================
-- Step 4: Grant Execute Permissions
-- ============================================================================

-- Grant execute permissions on helper functions to all authenticated users
GRANT EXECUTE ON FUNCTION is_service_account() TO authenticated;
GRANT EXECUTE ON FUNCTION is_admin() TO authenticated;
GRANT EXECUTE ON FUNCTION current_user_id() TO authenticated;
GRANT EXECUTE ON FUNCTION is_service_role() TO authenticated;

-- Also grant to anon for public queries (they will return false for auth checks)
GRANT EXECUTE ON FUNCTION is_service_account() TO anon;
GRANT EXECUTE ON FUNCTION is_admin() TO anon;
GRANT EXECUTE ON FUNCTION current_user_id() TO anon;
GRANT EXECUTE ON FUNCTION is_service_role() TO anon;

-- ============================================================================
-- Step 5: Update app_users Policies for Service Account
-- ============================================================================

-- Drop existing policies to recreate with service account support
DROP POLICY IF EXISTS "Service role manages app users" ON public.app_users;
DROP POLICY IF EXISTS "Users can view their own app_user record" ON public.app_users;

-- Service role and service account can manage all app_users
CREATE POLICY "app_users_service_all"
  ON public.app_users
  FOR ALL
  USING (
    auth.role() = 'service_role' OR
    is_service_account()
  )
  WITH CHECK (
    auth.role() = 'service_role' OR
    is_service_account()
  );

-- Authenticated users can view their own record
CREATE POLICY "app_users_user_select"
  ON public.app_users
  FOR SELECT
  USING (
    auth.role() = 'service_role' OR
    is_service_account() OR
    clerk_user_id = auth.uid()::text
  );

-- Admins can view all records
CREATE POLICY "app_users_admin_select"
  ON public.app_users
  FOR SELECT
  USING (is_admin());

COMMENT ON POLICY "app_users_service_all" ON public.app_users IS
  'Service role and service account have full access to app_users';
COMMENT ON POLICY "app_users_user_select" ON public.app_users IS
  'Users can view their own app_user record';
COMMENT ON POLICY "app_users_admin_select" ON public.app_users IS
  'Admins can view all app_user records';

-- ============================================================================
-- Step 6: Add Audit Logging
-- ============================================================================

-- Add audit logging for service account actions
CREATE TABLE IF NOT EXISTS service_account_audit (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  service_account_id TEXT NOT NULL,
  action TEXT NOT NULL,
  resource_type TEXT,
  resource_id TEXT,
  metadata JSONB DEFAULT '{}'::jsonb,
  success BOOLEAN NOT NULL DEFAULT true,
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

CREATE INDEX IF NOT EXISTS idx_service_account_audit_account_id
  ON service_account_audit(service_account_id);
CREATE INDEX IF NOT EXISTS idx_service_account_audit_created_at
  ON service_account_audit(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_service_account_audit_resource
  ON service_account_audit(resource_type, resource_id);

COMMENT ON TABLE service_account_audit IS
  'Audit log for service account actions to track backend operations';

-- Enable RLS on audit table
ALTER TABLE service_account_audit ENABLE ROW LEVEL SECURITY;

-- Service role and service account can write to audit log
CREATE POLICY "service_account_audit_service_insert"
  ON service_account_audit
  FOR INSERT
  WITH CHECK (
    auth.role() = 'service_role' OR
    is_service_account()
  );

-- Admins can read audit logs
CREATE POLICY "service_account_audit_admin_select"
  ON service_account_audit
  FOR SELECT
  USING (is_admin());

-- Service account can read its own audit logs
CREATE POLICY "service_account_audit_self_select"
  ON service_account_audit
  FOR SELECT
  USING (
    is_service_account() AND
    service_account_id = auth.uid()::text
  );

-- ============================================================================
-- Step 7: Create Service Account Activity Tracking
-- ============================================================================

-- Function to log service account activity
CREATE OR REPLACE FUNCTION log_service_account_activity(
  p_action TEXT,
  p_resource_type TEXT DEFAULT NULL,
  p_resource_id TEXT DEFAULT NULL,
  p_metadata JSONB DEFAULT '{}'::jsonb,
  p_success BOOLEAN DEFAULT true,
  p_error_message TEXT DEFAULT NULL
)
RETURNS UUID
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  v_audit_id UUID;
BEGIN
  -- Only log if current user is a service account
  IF NOT is_service_account() THEN
    RAISE EXCEPTION 'Only service accounts can log audit entries';
  END IF;

  INSERT INTO service_account_audit (
    service_account_id,
    action,
    resource_type,
    resource_id,
    metadata,
    success,
    error_message
  ) VALUES (
    auth.uid()::text,
    p_action,
    p_resource_type,
    p_resource_id,
    p_metadata,
    p_success,
    p_error_message
  )
  RETURNING id INTO v_audit_id;

  RETURN v_audit_id;
END;
$$;

COMMENT ON FUNCTION log_service_account_activity IS
  'Logs service account activity to the audit table';

GRANT EXECUTE ON FUNCTION log_service_account_activity TO authenticated;

-- ============================================================================
-- Summary
-- ============================================================================

DO $$
BEGIN
  RAISE NOTICE '
  ============================================================================
  Service Account RBAC Setup Complete
  ============================================================================

  Created:
  - Service account user with ID: 00000000-0000-0000-0000-000000000001
  - app_users.is_service_account column
  - Helper functions: is_service_account(), is_admin(), current_user_id(), is_service_role()
  - Updated app_users RLS policies with service account support
  - service_account_audit table for tracking service account actions
  - log_service_account_activity() function for audit logging

  Next Steps:
  1. Generate JWT token for service account (see lib/supabase/service-account.ts)
  2. Update backend code to use service account client instead of service_role
  3. Apply migration 20251009_002_complete_rls_coverage.sql for full RLS coverage

  ============================================================================
  ';
END $$;

COMMIT;
